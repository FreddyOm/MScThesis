\chapter{Appendix} \label{cpt-appendix}

\section*{CPU Frame Times}


\begin{figure}[!htbp]              % Lucy CPU times
    \begin{center}
      \begin{tikzpicture}
        \begin{axis}[
            width=\linewidth,
            height=100px,
            xlabel={Frames},
            ylabel={Frame Time (s)},
            grid,
            xmin=0,
            xmax=1868,
            ymin=0,
            ymax=0.04,
            legend style={at={(0.5,1.8)}, anchor=north, legend columns=2},
          ]
          \addplot[blue, no marks, solid] table[col sep=comma, x=frame, x expr=\thisrow{frame} * 1868 / 1864, y=time]{./plotdata/cpu/lucy_256_frameTime_pooc.csv};
          \addplot[red, no marks, solid] table[col sep=comma, x=frame, x expr=\thisrow{frame} * 1868 / 1868, y=time]{./plotdata/cpu/lucy_256_frameTime.csv};
          \legend{Per-Octree Occlsion Culling, Per-Meshlet Occlusion Culling}
        \end{axis}
      \end{tikzpicture}
    \end{center}
    \caption{The frame time measured over the course of the test animation on the \ac{CPU} side for the \emph{Lucy} scene.
    The frame times were artificially capped to 30, 60 or 120 Hz by \emph{Diligent Engine}.}
    \label{plt:lucy-256-culling-cpu-frame-time}
  \end{figure}

\begin{figure}[!htbp]              % Bunny CPU times
    \begin{center}
      \begin{tikzpicture}
        \begin{axis}[
            width=\linewidth,
            height=100px,
            xlabel={Frames},
            ylabel={Frame Time (s)},
            grid,
            xmin=0,
            xmax=1701,
            ymin=0,
            ymax=0.04,
            legend style={at={(0.5,1.8)}, anchor=north, legend columns=2},
          ]
          \addplot[blue, no marks, solid] table[col sep=comma, x=frame, x expr=\thisrow{frame} * 1701 / 1548, y=time]{./plotdata/cpu/bunny_256_frameTime_pooc.csv};
          \addplot[red, no marks, solid] table[col sep=comma, x=frame, x expr=\thisrow{frame} * 1701 / 1701, y=time]{./plotdata/cpu/bunny_256_frameTime.csv};
          \legend{Per-Octree Occlsion Culling, Per-Meshlet Occlusion Culling}
        \end{axis}
      \end{tikzpicture}
    \end{center}
    \caption{The frame time measured over the course of the test animation on the \ac{CPU} side for the \emph{Bunny} scene.
    The frame times were artificially capped to 30, 60 or 120 Hz by \emph{Diligent Engine}.}
    \label{plt:bunny-256-culling-cpu-frame-time}
  \end{figure}

\begin{figure}[!htbp]              % Torus CPU times
    \begin{center}
      \begin{tikzpicture}
        \begin{axis}[
            width=\linewidth,
            height=100px,
            xlabel={Frames},
            ylabel={Frame Time (s)},
            grid,
            xmin=0,
            xmax=1786,
            ymin=0,
            ymax=0.04,
            legend style={at={(0.5,1.8)}, anchor=north, legend columns=2},
          ]
          \addplot[blue, no marks, solid] table[col sep=comma, x=frame, x expr=\thisrow{frame} * 1786 / 1555, y=time]{./plotdata/cpu/torus_256_frameTime_pooc.csv};
          \addplot[red, no marks, solid] table[col sep=comma, x=frame, x expr=\thisrow{frame} * 1786 / 1786, y=time]{./plotdata/cpu/torus_256_frameTime.csv};
          \legend{Per-Octree Occlsion Culling, Per-Meshlet Occlusion Culling}
        \end{axis}
      \end{tikzpicture}
    \end{center}
    \caption{The frame time measured over the course of the test animation on the \ac{CPU} side for the \emph{Torus} scene.
    The frame times were artificially capped to 30, 60 or 120 Hz by \emph{Diligent Engine}.}
    \label{plt:torus-256-culling-cpu-frame-time}
  \end{figure}

\begin{figure}[!htbp]              % Terrain CPU times
    \begin{center}
      \begin{tikzpicture}
        \begin{axis}[
            width=\linewidth,
            height=100px,
            xlabel={Frames},
            ylabel={Frame Time (s)},
            grid,
            xmin=0,
            xmax=1814,
            ymin=0,
            ymax=0.04,
            legend style={at={(0.5,1.8)}, anchor=north, legend columns=2},
          ]
          \addplot[blue, no marks, solid] table[col sep=comma, x=frame, x expr=\thisrow{frame} * 1814 / 1572, y=time]{./plotdata/cpu/terrain_256_frameTime_pooc.csv};
          \addplot[red, no marks, solid] table[col sep=comma, x=frame, x expr=\thisrow{frame} * 1814 / 1814, y=time]{./plotdata/cpu/terrain_256_frameTime.csv};
          \legend{Per-Octree Occlsion Culling, Per-Meshlet Occlusion Culling}
        \end{axis}
      \end{tikzpicture}
    \end{center}
    \caption{The frame time measured over the course of the test animation on the \ac{CPU} side for the \emph{Terrain} scene.
    The frame times were artificially capped to 30, 60 or 120 Hz by \emph{Diligent Engine}.}
    \label{plt:terrain-256-culling-cpu-frame-time}
  \end{figure}

\begin{figure}[!htbp]              % Hairball CPU times
    \begin{center}
      \begin{tikzpicture}
        \begin{axis}[
            width=\linewidth,
            height=100px,
            xlabel={Frames},
            ylabel={Frame Time (s)},
            grid,
            xmin=0,
            xmax=1446,
            ymin=0,
            ymax=0.025,
            legend style={at={(0.5,1.8)}, anchor=north, legend columns=2},
          ]
          \addplot[blue, no marks, solid] table[col sep=comma, x=frame, x expr=\thisrow{frame} * 1446 / 1422, y=time]{./plotdata/cpu/hairball_256_frameTime_pooc.csv};
          \addplot[red, no marks, solid] table[col sep=comma, x=frame, x expr=\thisrow{frame} * 1446 / 1446, y=time]{./plotdata/cpu/hairball_256_frameTime.csv};
          \legend{Per-Octree Occlsion Culling, Per-Meshlet Occlusion Culling}
        \end{axis}
      \end{tikzpicture}
    \end{center}
    \caption{The frame time measured over the course of the test animation on the \ac{CPU} side for the \emph{Hairball} scene.
    The frame times were artificially capped to 30, 60 or 120 Hz by \emph{Diligent Engine}.}
    \label{plt:hairball-256-culling-cpu-frame-time}
  \end{figure}

\clearpage

\section*{Project Code}


% - structures
\begin{lstlisting}

    // structures.fxh
    #ifndef GROUP_SIZE
    #define GROUP_SIZE 64   // max 1024
    #endif
    
    struct OctreeLeafNode
    {
        float4 BasePosAndScale;
        float4 RandomValue;
        
        // Payload
        int VoxelBufStartIndex;
        int VoxelBufDataCount;
        
        int2 Padding;
    };
    
    struct DepthPrepassDrawTask
    {
        float4 BasePosAndScale;
        int BestOccluderCount;
        int3 Padding;
    };
    
    struct VoxelBufData
    {
        float4 BasePosAndScale;
    };
    
    struct Constants
    {
        float4x4 ViewMat;
        float4x4 ViewProjMat;
        
        float4 Frustum[6];
        float DepthBias;
        uint RenderOptions;
    };
    
    struct Payload
    {
        // Currently, DXC fails to compile the code when
        // the struct declares float3 Pos, so we have to
        // use struct of arrays
        float PosX[GROUP_SIZE];
        float PosY[GROUP_SIZE];
        float PosZ[GROUP_SIZE];
        float Scale[GROUP_SIZE];
        float MSRand[GROUP_SIZE];
    };
    
    struct HiZConstants
    {
        uint2 InputDimensions;
        uint2 OutputDimensions;
        uint Level;
        uint Padding[3];
    };

\end{lstlisting}

% - mesh shader
\begin{lstlisting}
#include "structures.fxh"

cbuffer cbConstants
{
    Constants g_Constants;
}

struct PSInput 
{
    float4 Pos   : SV_POSITION; 
    float4 Color : COLOR;
    float2 UV    : TEXCOORD;
    float3 Normal : NORMAL;
};

static const uint constCubeIndices[12 * 3] =
{
    2, 0, 1,
    2, 3, 0,
    4, 6, 5,
    4, 7, 6,
    8, 10, 9,
    8, 11, 10,
    12, 14, 13,
    12, 15, 14,
    16, 18, 17,
    16, 19, 18,
    20, 21, 22,
    20, 22, 23,
};

static const float3 constCubePos[24] =
{
    float3(-1, -1, -1),
    float3(-1, +1, -1),
    float3(+1, +1, -1),
    float3(+1, -1, -1),
    float3(-1, -1, -1),
    float3(-1, -1, +1),
    float3(+1, -1, +1),
    float3(+1, -1, -1),
    float3(+1, -1, -1),
    float3(+1, -1, +1),
    float3(+1, +1, +1),
    float3(+1, +1, -1),
    float3(+1, +1, -1),
    float3(+1, +1, +1),
    float3(-1, +1, +1),
    float3(-1, +1, -1),
    float3(-1, +1, -1),
    float3(-1, +1, +1),
    float3(-1, -1, +1),
    float3(-1, -1, -1),
    float3(-1, -1, +1),
    float3(+1, -1, +1),
    float3(+1, +1, +1),
    float3(-1, +1, +1),
};

static const float2 constCubeUVs[24] =
{
    float2(0.0f, 0.5f),
    float2(0.0f, 0.0f),
    float2(0.5f, 0.0f),
    float2(0.5f, 0.5f),
    float2(0.0f, 0.5f),
    float2(0.5f, 0.5f),
    float2(0.5f, 1.0f),
    float2(0.0f, 1.0f),
    float2(0.5f, 0.5f),
    float2(0.0f, 0.5f),
    float2(0.0f, 0.0f),
    float2(0.5f, 0.0f),
    float2(0.5f, 0.5f),
    float2(1.0f, 0.5f),
    float2(1.0f, 1.0f),
    float2(0.5f, 1.0f),
    float2(0.0f, 0.0f),
    float2(0.5f, 0.0f),
    float2(0.5f, 0.5f),
    float2(0.0f, 0.5f),
    float2(0.5f, 0.5f),
    float2(0.0f, 0.5f),
    float2(0.0f, 0.0f),
    float2(0.5f, 0.0f),
};

static const float3 constCubeNormals[24] =
{
    float3(0, 0, 1),
    float3(0, 0, 1),
    float3(0, 0, 1),
    float3(0, 0, 1),

    float3(0, 0, -1),
    float3(0, 0, -1),
    float3(0, 0, -1),
    float3(0, 0, -1),

    float3(1, 0, 0),
    float3(1, 0, 0),
    float3(1, 0, 0),
    float3(1, 0, 0),

    float3(-1, 0, 0),
    float3(-1, 0, 0),
    float3(-1, 0, 0),
    float3(-1, 0, 0),

    float3(0, 1, 0),
    float3(0, 1, 0),
    float3(0, 1, 0),
    float3(0, 1, 0),

    float3(0, -1, 0),
    float3(0, -1, 0),
    float3(0, -1, 0),
    float3(0, -1, 0),
};

const static float4 primitiveColors[20] =
{
    float4(76.f / 255.f, 74.f / 255.f, 89.f / 255.f, 1.0f),
    float4(255.f / 255.f, 107.f / 255.f, 107.f / 255.f, 1.0f),
    float4(50.f / 255.f, 168.f / 255.f, 82.f / 255.f, 1.0f),
    float4(255.f / 255.f, 195.f / 255.f, 0.f / 255.f, 1.0f),
    float4(0.f / 255.f, 153.f / 255.f, 255.f / 255.f, 1.0f),
    float4(255.f / 255.f, 128.f / 255.f, 0.f / 255.f, 1.0f),
    float4(138.f / 255.f, 43.f / 255.f, 226.f / 255.f, 1.0f),
    float4(0.f / 255.f, 204.f / 255.f, 102.f / 255.f, 1.0f),
    float4(255.f / 255.f, 0.f / 255.f, 127.f / 255.f, 1.0f),
    float4(204.f / 255.f, 204.f / 255.f, 0.f / 255.f, 1.0f),
    float4(102.f / 255.f, 204.f / 255.f, 255.f / 255.f, 1.0f),
    float4(255.f / 255.f, 153.f / 255.f, 204.f / 255.f, 1.0f),
    float4(153.f / 255.f, 51.f / 255.f, 0.f / 255.f, 1.0f),
    float4(0.f / 255.f, 255.f / 255.f, 204.f / 255.f, 1.0f),
    float4(204.f / 255.f, 0.f / 255.f, 204.f / 255.f, 1.0f),
    float4(255.f / 255.f, 204.f / 255.f, 153.f / 255.f, 1.0f),
    float4(51.f / 255.f, 102.f / 255.f, 0.f / 255.f, 1.0f),
    float4(102.f / 255.f, 0.f / 255.f, 102.f / 255.f, 1.0f),
    float4(255.f / 255.f, 255.f / 255.f, 153.f / 255.f, 1.0f),
    float4(0.f / 255.f, 102.f / 255.f, 204.f / 255.f, 1.0f),
};

float4 getRandomPrimitiveColor(float randMeshletVal)
{    
    uint colorIdx = floor(randMeshletVal * 20);
    return primitiveColors[colorIdx];
}

bool GetRenderOption(uint bit)
{
    return (g_Constants.RenderOptions & (1u << bit)) 
    ? true : false;
}

[numthreads(24, 1, 1)]
[outputtopology("triangle")]
void main(in uint I : SV_GroupIndex,
          in uint gid : SV_GroupID,
          in  payload  Payload  payload,
          out indices uint3 tris[12],
          out vertices PSInput verts[24])
{        
    SetMeshOutputCounts(24, 12);
    
    float3 pos;
    float scale = payload.Scale[gid];
    float randValue = payload.MSRand[gid];
    pos.x = payload.PosX[gid];
    pos.y = payload.PosY[gid];
    pos.z = payload.PosZ[gid];
    
    verts[I].Pos = mul(float4(pos + constCubePos[I].xyz * 
    scale * 0.5, 1.0), g_Constants.ViewProjMat);
    verts[I].Normal = mul(float4(constCubeNormals[I], 0.0), 
    g_Constants.ViewProjMat).xyz;
    
    verts[I].UV = constCubeUVs[I].xy;
    verts[I].Color = (GetRenderOption(5) ? 1 : 0) * 
    getRandomPrimitiveColor((randValue + 
    ((1 - GetRenderOption(6)) * 0.1f * gid)) % 1.0f);
    
    if (I < 12)
    {
        tris[I] = float3(constCubeIndices[I * 3 + 0], 
        constCubeIndices[I * 3 + 1], 
        constCubeIndices[I * 3 + 2]);
    }
}
\end{lstlisting}

% - task shader
\begin{lstlisting}
#include "structures.fxh"

#ifndef SHOW_STATISTICS
#define SHOW_STATISTICS 1
#endif


RWByteAddressBuffer Statistics : register(u0);
StructuredBuffer<VoxelBufData> VoxelPositionBuffer 
: register(t1);
StructuredBuffer<OctreeLeafNode> OctreeNodes : register(t2);
Texture2D<float> HiZPyramid : register(s0);

    cbuffer cbConstants : register(b0)
    {
    Constants g_Constants;
    }

    groupshared Payload s_Payload;

    bool GetRenderOption(uint bit)
    {
        return (g_Constants.RenderOptions & (1u << bit)) 
        ?  true : false;
    }

    bool IsInCameraFrustum(float4 basePosAndScale)
    {
    float4 center = float4(basePosAndScale.xyz, 1.0f);
    float radius = 0.71f * abs(basePosAndScale.z);
    
    for (int i = 0; i < 6; ++i)
    {
        if (dot(g_Constants.Frustum[i], center) < -radius)
            return false;
    }
    return true;
    }

    float GetMinBoundVertex(float4 BasePosAndScale, 
    out float4 minXmaxXminYmaxY)
    {
    float3 basePos = BasePosAndScale.xyz;
    float halfScale = BasePosAndScale.w * 0.5;
    
    float4x3 corners1 = float4x3(
        basePos + float3(-halfScale, -halfScale, -halfScale),
        basePos + float3(-halfScale, -halfScale, halfScale),
        basePos + float3(-halfScale, halfScale, -halfScale),
        basePos + float3(-halfScale, halfScale, halfScale)
    );
    
    float4x3 corners2 = float4x3(
        basePos + float3(halfScale, -halfScale, -halfScale),
        basePos + float3(halfScale, -halfScale, halfScale),
        basePos + float3(halfScale, halfScale, -halfScale),
        basePos + float3(halfScale, halfScale, halfScale)
    );
    
    float4 clipPos1 = mul(float4(corners1[0].xyz, 1.0), 
    g_Constants.ViewProjMat);
    float4 clipPos2 = mul(float4(corners1[1].xyz, 1.0), 
    g_Constants.ViewProjMat);
    float4 clipPos3 = mul(float4(corners1[2].xyz, 1.0), 
    g_Constants.ViewProjMat);
    float4 clipPos4 = mul(float4(corners1[3].xyz, 1.0), 
    g_Constants.ViewProjMat);
        
    clipPos1 /= clipPos1.w; clipPos1 = clamp(clipPos1, -1, 1);
    clipPos2 /= clipPos2.w; clipPos2 = clamp(clipPos2, -1, 1);
    clipPos3 /= clipPos3.w; clipPos3 = clamp(clipPos3, -1, 1);
    clipPos4 /= clipPos4.w; clipPos4 = clamp(clipPos4, -1, 1);
    
    minXmaxXminYmaxY.x = min(min(clipPos1.x, clipPos2.x), 
    min(clipPos3.x, clipPos4.x));
    minXmaxXminYmaxY.y = max(max(clipPos1.x, clipPos2.x), 
    max(clipPos3.x, clipPos4.x));
    minXmaxXminYmaxY.z = min(min(clipPos1.y, clipPos2.y), 
    min(clipPos3.y, clipPos4.y));
    minXmaxXminYmaxY.w = max(max(clipPos1.y, clipPos2.y), 
    max(clipPos3.y, clipPos4.y));
    
    float minZ = min(min(clipPos1.z, clipPos2.z), 
    min(clipPos3.z, clipPos4.z));
    
    clipPos1 = mul(float4(corners2[0].xyz, 1.0), 
    g_Constants.ViewProjMat);
    clipPos2 = mul(float4(corners2[1].xyz, 1.0), 
    g_Constants.ViewProjMat);
    clipPos3 = mul(float4(corners2[2].xyz, 1.0), 
    g_Constants.ViewProjMat);
    clipPos4 = mul(float4(corners2[3].xyz, 1.0), 
    g_Constants.ViewProjMat);
    
    clipPos1 /= clipPos1.w; clipPos1 = clamp(clipPos1, -1, 1);
    clipPos2 /= clipPos2.w; clipPos2 = clamp(clipPos2, -1, 1);
    clipPos3 /= clipPos3.w; clipPos3 = clamp(clipPos3, -1, 1);
    clipPos4 /= clipPos4.w; clipPos4 = clamp(clipPos4, -1, 1);
    
    minXmaxXminYmaxY.x = min(min(min(clipPos1.x, clipPos2.x), 
    min(clipPos3.x, clipPos4.x)), minXmaxXminYmaxY.x);
    minXmaxXminYmaxY.y = max(max(max(clipPos1.x, clipPos2.x), 
    max(clipPos3.x, clipPos4.x)), minXmaxXminYmaxY.y);
    minXmaxXminYmaxY.z = min(min(min(clipPos1.y, clipPos2.y), 
    min(clipPos3.y, clipPos4.y)), minXmaxXminYmaxY.z);
    minXmaxXminYmaxY.w = max(max(max(clipPos1.y, clipPos2.y), 
    max(clipPos3.y, clipPos4.y)), minXmaxXminYmaxY.w);
    
    float minZ2 = min(min(clipPos1.z, clipPos2.z), 
    min(clipPos3.z, clipPos4.z));
    
    return saturate(min(minZ, minZ2));
    }

    bool IsVisible(OctreeLeafNode node, uint I)
    {    
    if (node.VoxelBufDataCount == 0)
        return false;
    
    float4 worldPosAndScale = GetRenderOption(0) ? 
    VoxelPositionBuffer[node.VoxelBufStartIndex + I].
    BasePosAndScale : node.BasePosAndScale;
    
    float4 clipPosVertices   = float4(0.f, 0.f, 0.f, 0.f); 
    float  perspectiveDivide = 0.f;
    float  minZ = 
    GetMinBoundVertex(worldPosAndScale, clipPosVertices);
    
    float2 upperLeftBounding    = 
    float2(clipPosVertices.x, clipPosVertices.w);
    float2 upperRightBounding   = 
    float2(clipPosVertices.y, clipPosVertices.w);
    float2 lowerLeftBounding    = 
    float2(clipPosVertices.x, clipPosVertices.z);
    float2 lowerRightBounding   = 
    float2(clipPosVertices.y, clipPosVertices.z);
    
    
    float2 upperLeftBoundingUV = 
    float2(upperLeftBounding.x * 0.5 + 0.5, 
    upperLeftBounding.y * -0.5 + 0.5);
    float2 upperRightBoundingUV = 
    float2(upperRightBounding.x * 0.5 + 0.5, 
    upperRightBounding.y * -0.5 + 0.5);
    float2 lowerLeftBoundingUV = 
    float2(lowerLeftBounding.x * 0.5 + 0.5, 
    lowerLeftBounding.y * -0.5 + 0.5);
    float2 lowerRightBoundingUV = 
    float2(lowerRightBounding.x * 0.5 + 0.5, 
    lowerRightBounding.y * -0.5 + 0.5);
    
    
    uint numLevels = 1; // At least one mip level is assumed
    uint outVar;
    HiZPyramid.GetDimensions(outVar, outVar, outVar, numLevels);
  
    for (int mipLevel = max(numLevels - 1, 1); 
        mipLevel >= 0; --mipLevel)
    {
        uint2 texDims;
        HiZPyramid.GetDimensions(
            mipLevel, texDims.x, texDims.y, outVar);
        
        float hiZDepthUL = 
        HiZPyramid.Load(
        int3(uint2(upperLeftBoundingUV * texDims), mipLevel));
        float hiZDepthUR = 
        HiZPyramid.Load(
        int3(uint2(upperRightBoundingUV * texDims), mipLevel));
        float hiZDepthLL = 
        HiZPyramid.Load(
        int3(uint2(lowerLeftBoundingUV * texDims), mipLevel));
        float hiZDepthLR = 
        HiZPyramid.Load(
        int3(uint2(lowerRightBoundingUV * texDims), mipLevel));
        
        if (all(
        float4(hiZDepthUL, hiZDepthUR, hiZDepthLL, hiZDepthLR)
            ))
        {
            float maxHiZDepth = 
            max(max(hiZDepthLL, hiZDepthLR), 
            max(hiZDepthUL, hiZDepthUR));
        
            if (maxHiZDepth < minZ)
                return false;
        }
    }
    
    return true;
}

groupshared uint s_TaskCount;
groupshared uint s_OctreeNodeCount;

[numthreads(GROUP_SIZE, 1, 1)]
void main(in uint I  : SV_GroupIndex,
          in uint wg : SV_GroupID)
    {
#if SHOW_STATISTICS
    if (I == 0)
    {
        s_TaskCount = 0;
        s_OctreeNodeCount = 0;
    }
#endif

    GroupMemoryBarrierWithGroupSync();

    const uint gid = wg * GROUP_SIZE + I;    
    OctreeLeafNode node = OctreeNodes[wg];
    
    float meshletColorRndValue = node.RandomValue.x;
    int taskCount = (int) node.RandomValue.y;
    int padding = (int) node.RandomValue.z;

    uint cullVoxel = 0;
    cullVoxel += !(node.VoxelBufDataCount > 0);
    cullVoxel += !(I < node.VoxelBufDataCount);
    cullVoxel += (GetRenderOption(2) == true && 
    IsInCameraFrustum(node.BasePosAndScale)) ? 0 : 1;
    cullVoxel += (GetRenderOption(1) == false 
    || IsVisible(node, I)) ? 0 : 1;
    
    if (cullVoxel == 0)
    {
        VoxelBufData voxel  = 
        VoxelPositionBuffer[node.VoxelBufStartIndex + I];
        float3       pos    = 
        voxel.BasePosAndScale.xyz;
        float        scale  = 
        voxel.BasePosAndScale.w;
        
        uint index = 0;
        InterlockedAdd(s_TaskCount, 1, index);

        s_Payload.PosX[index] = pos.x;
        s_Payload.PosY[index] = pos.y;
        s_Payload.PosZ[index] = pos.z;
        s_Payload.Scale[index] = scale;
        s_Payload.MSRand[index] = meshletColorRndValue;
        
#if SHOW_STATISTICS
        
        if (node.VoxelBufDataCount > 0 && I == 0)
        {
            GroupMemoryBarrier();
            uint temp;
            InterlockedAdd(s_OctreeNodeCount, 1, temp);         
        }
#endif
    }
    
    GroupMemoryBarrierWithGroupSync();

    if (node.VoxelBufDataCount > 0 && I == 0)
    {
#if SHOW_STATISTICS
        uint orig_value_task_count;
        Statistics.InterlockedAdd(0, 
        s_TaskCount, orig_value_task_count);
        
        uint orig_value_ocn_count;
        Statistics.InterlockedAdd(4, 
        s_OctreeNodeCount, orig_value_ocn_count);
#endif
    }    
    DispatchMesh(s_TaskCount, 1, 1, s_Payload);
    }

\end{lstlisting}

% - task shader best occluders
\begin{lstlisting}
#include "structures.fxh"

#ifndef SHOW_STATISTICS
#define SHOW_STATISTICS 1
#endif

StructuredBuffer<DepthPrepassDrawTask> BestOccluders;

cbuffer cbConstants
{
    Constants g_Constants;
}

groupshared Payload s_Payload;

bool IsVisible(float4 basePosAndScale)
{
    float4 center = float4(basePosAndScale.xyz, 1.0f);
    float radius = 0.71f * abs(basePosAndScale.z);
    
    for (int i = 0; i < 6; ++i)
    {
        if (dot(g_Constants.Frustum[i], center) < -radius)
            return false;
    }
    return true;
}

groupshared uint s_TaskCount;

[numthreads(GROUP_SIZE, 1, 1)]
void main(in uint I  : SV_GroupIndex,
          in uint wg : SV_GroupID)
{
    if (I == 0)
    {
        s_TaskCount = 0;
    }

    GroupMemoryBarrierWithGroupSync();

    const uint gid = wg * GROUP_SIZE + I;
    
    int bestOccluderCount = 
    BestOccluders[0].BestOccluderCount;
    
    if (gid < bestOccluderCount)
    {
        DepthPrepassDrawTask node = 
        BestOccluders[gid];
        float3 pos = 
        node.BasePosAndScale.xyz;
        float scale = 
        node.BasePosAndScale.w;
    
        uint index = 0;
        InterlockedAdd(s_TaskCount, 1, index);

        s_Payload.PosX[index] = pos.x;
        s_Payload.PosY[index] = pos.y;
        s_Payload.PosZ[index] = pos.z;
        s_Payload.Scale[index] = scale;
        s_Payload.MSRand[index] = 0.0f;
    }
    
    GroupMemoryBarrierWithGroupSync();
    
    DispatchMesh(s_TaskCount, 1, 1, s_Payload);
}

\end{lstlisting}

% - pixel shader
\begin{lstlisting}
#include "structures.fxh"

Texture2D g_Texture;
SamplerState g_Texture_sampler;

RWTexture2D<uint> g_OverdrawUAV;

struct PSInput
{
    float4 Pos : SV_POSITION;
    float4 Color : COLOR;
    float2 UV : TEXCOORD;
    float3 Normal : NORMAL;
};

struct PSOutput
{
    float4 Color : SV_TARGET;
};

cbuffer cbConstants
{
    Constants g_Constants;
}

static const float3 g_LightDirection = 
normalize(float3(-1.0f, -1.0f, -1.0f));
static const float4 g_LightColor = 
float4(1.0f, 1.0f, 1.0f, 1.0f);
static const float g_AmbientIntensity = 0.2f;

bool GetRenderOption(uint bit)
{
    return (g_Constants.RenderOptions & 
    (1u << bit)) ? true : false;
}

void main(in PSInput PSIn,
          out PSOutput PSOut)
{    
    uint2 pixelCoord = uint2(PSIn.Pos.xy);
    InterlockedAdd(g_OverdrawUAV[pixelCoord], 1);
    
    float3 normal = normalize(PSIn.Normal);
    float diffuseIntensity = 
    saturate(dot(normal, -g_LightDirection));

    float4 diffuseColor = 
    diffuseIntensity * g_LightColor;
    float4 ambientColor = 
    g_AmbientIntensity * g_LightColor;
    float4 finalColor = 
    ambientColor + diffuseColor;

    if (length(PSIn.Color.xyz) > 0.0f)
    {
        PSOut.Color = PSIn.Color * 
        (GetRenderOption(4) ? finalColor : 1.0f);
    }
    else
    {
        PSOut.Color = 
        g_Texture.Sample(g_Texture_sampler, PSIn.UV) * 
        (GetRenderOption(4) ? finalColor : 1.0f);
    }
}

\end{lstlisting}

% - cs generate HiZ
\begin{lstlisting}

RWTexture2D<float> InputTexture : register(u0);
RWTexture2D<float> OutputTexture : register(u1);

cbuffer Constants : register(b0)
{
    uint2 InputDimensions;
    uint2 OutputDimensions;
    uint Level;
};

#define THREAD_GROUP_SIZE 32

[numthreads(THREAD_GROUP_SIZE, THREAD_GROUP_SIZE, 1)]
void main(uint3 DTid : SV_DispatchThreadID)
{
    if (any(DTid.xy >= OutputDimensions))
        return;

    uint2 InputPos = DTid.xy * 2;

    float z1 = InputTexture[InputPos];
    float z2 = InputTexture[min(InputPos + uint2(1, 0), 
    InputDimensions - 1)];
    float z3 = InputTexture[min(InputPos + uint2(0, 1), 
    InputDimensions - 1)];
    float z4 = InputTexture[min(InputPos + uint2(1, 1), 
    InputDimensions - 1)];

    float maxZ = max(max(z1, z2), max(z3, z4));

    OutputTexture[DTid.xy] = maxZ;
}

\end{lstlisting}

% - aabb
\begin{lstlisting}
#pragma once

struct AABB
{
    DirectX::XMFLOAT3 min = {};
    DirectX::XMFLOAT3 max = {};

    DirectX::XMFLOAT3 Center() const
    {
        return {(min.x + max.x) / 2.f, 
        (min.y + max.y) / 2.f, (min.z + max.z) / 2.f};
    }

    DirectX::XMFLOAT4 CenterAndScale() const
    {
        return {(min.x + max.x) / 2.f, (min.y + max.y) / 2.f, 
        (min.z + max.z) / 2.f, max.x - min.x};
    }

    AABB Octant(unsigned int octant) const
    {
        DirectX::XMFLOAT3 center = Center();
        DirectX::XMFLOAT3 newMin, newMax;
        newMin.x = (octant & 1) ? center.x : min.x;
        newMin.y = (octant & 2) ? center.y : min.y;
        newMin.z = (octant & 4) ? center.z : min.z;
        newMax.x = (octant & 1) ? max.x : center.x;
        newMax.y = (octant & 2) ? max.y : center.y;
        newMax.z = (octant & 4) ? max.z : center.z;
        return {newMin, newMax};
    }
};
\end{lstlisting}

% - octree.h
\begin{lstlisting}
#pragma once

#include <DirectXMath.h>
#include <array>
#include <vector>
#include <set>
#include "../DrawTask.h"
#include "aabb.h"

extern std::vector<AABB> OTVoxelBoundBuffer;

bool          IntersectAABBAABB(const AABB& first, 
const AABB& second);
bool          IntersectAABBPoint(const AABB& first, 
const DirectX::XMFLOAT3& second);
extern AABB   GetVoxelBounds(size_t index);

template<typename T>
class OctreeNode
{
public:
    AABB                       bounds                = {};
    unsigned int               maxObjectsPerLeaf     = 0;
    bool                       isLeaf                = {};

    AABB   rootBounds = {};
    size_t gridSize   = 0;
    size_t& g_hierarchyDepth;
    int hierarchyIndex  = 0;


    std::vector<AABB>& nodeBuffer;
    std::array<OctreeNode*, 8> children              = {};
    std::vector<size_t>        objectIndices         = {};

    OctreeNode(const AABB& bounds, 
    std::vector<AABB>& nodeBuffer, 
    size_t gridSize, AABB rootBounds, size_t& g_hierarchyDepth, 
    int _hierarchyIndex, unsigned int maxObjectsPerLeaf = 64) :
    bounds(bounds), maxObjectsPerLeaf(maxObjectsPerLeaf), 
    isLeaf(true), nodeBuffer(nodeBuffer), gridSize(gridSize), 
    rootBounds(rootBounds), g_hierarchyDepth(g_hierarchyDepth)
    {
        children.fill(nullptr);
        objectIndices.reserve(maxObjectsPerLeaf);

        hierarchyIndex   = _hierarchyIndex + 1;
        g_hierarchyDepth = g_hierarchyDepth < 
        hierarchyIndex ? hierarchyIndex : g_hierarchyDepth;

        VERIFY_EXPR(gridSize > 0);
    }

    ~OctreeNode()
    {
        objectIndices.clear();
        
        for(auto & child : children)
        {
            delete child;
        }
    }

    void QueryAllNodes(
    std::vector<VoxelOC::VoxelBufData>& orderedVoxelDataBuf, 
    std::vector<VoxelOC::OctreeLeafNode>& octreeNodeBuffer)
    {
        for (int i = 0; i < children.size(); ++i)
        {
            if (children[i] != nullptr)
            {                
                children[i]->QueryAllNodes(
                    orderedVoxelDataBuf, octreeNodeBuffer);
            }
        }

        VoxelOC::OctreeLeafNode ocNode;
        ocNode.VoxelBufStartIndex = 
        static_cast<int>(orderedVoxelDataBuf.size());
        ocNode.VoxelBufIndexCount = 
        static_cast<int>(objectIndices.size());
        ocNode.BasePosAndScale = 
        bounds.CenterAndScale();

        if (objectIndices.size() > 0)
            octreeNodeBuffer.push_back(std::move(ocNode));

        for (int index = 0; 
        index < objectIndices.size(); ++index)
        {
            VoxelOC::VoxelBufData voxelData;
            voxelData.BasePosAndScale = 
            OTVoxelBoundBuffer[objectIndices[index]]
            .CenterAndScale();

            VERIFY_EXPR(voxelData.BasePosAndScale.w == 1);

            orderedVoxelDataBuf.push_back(std::move(voxelData));
        }
    }

    void QueryBestOccluders(
        std::vector<VoxelOC::DepthPrepassDrawTask>& 
        depthPrepassOTNodes)
    {
        for (int i = 0; i < children.size(); ++i)
        {
            if (children[i] != nullptr)
            {
                if (children[i]->IsFull())
                {
                    VoxelOC::DepthPrepassDrawTask drawTask{};
                    drawTask.BasePositionAndScale = 
                    children[i]->bounds.CenterAndScale();
                    depthPrepassOTNodes.push_back(
                        std::move(drawTask));
                    continue;
                }
                
                children[i]->QueryBestOccluders(
                    depthPrepassOTNodes);
            }
        }
    }

    void SplitNode()
    {
        if (!isLeaf) return;

        VERIFY_EXPR(bounds.max.x - bounds.min.x >= 4);

        DirectX::XMFLOAT3 center = {
                (bounds.min.x + bounds.max.x) * 0.5f,
                (bounds.min.y + bounds.max.y) * 0.5f,
                (bounds.min.z + bounds.max.z) * 0.5f
            };

        for (int i = 0; i < 8; ++i)
        {
            DirectX::XMFLOAT3 newMin{};
            DirectX::XMFLOAT3 newMax{};

            newMin.x = (i & 1) ? center.x : bounds.min.x;
            newMin.y = (i & 2) ? center.y : bounds.min.y;
            newMin.z = (i & 4) ? center.z : bounds.min.z;
            newMax.x = (i & 1) ? bounds.max.x : center.x;
            newMax.y = (i & 2) ? bounds.max.y : center.y;
            newMax.z = (i & 4) ? bounds.max.z : center.z;

            children[i] = new OctreeNode({newMin, newMax}, 
            nodeBuffer, gridSize, rootBounds, 
            g_hierarchyDepth, hierarchyIndex, maxObjectsPerLeaf);
        }

        isLeaf = false;
    }

    void InsertObject(size_t objectIndex, 
    const AABB objectBounds)
    {
        OctreeNode*              currentNode = this;
        std::vector<OctreeNode*> path;

        while (true)
        {
            if (!IntersectAABBPoint(bounds, 
            objectBounds.Center()))
            {
                return;
            }

            path.push_back(currentNode);

            if (currentNode->isLeaf)
            {
                if (currentNode->objectIndices.size() 
                < maxObjectsPerLeaf)
                {
                    currentNode->objectIndices.push_back(
                        objectIndex);
                    return;
                }
                else
                {
                    VERIFY_EXPR(currentNode->bounds.
                    CenterAndScale().w >= 4);
                    currentNode->SplitNode();

                    for (size_t index : 
                    currentNode->objectIndices)
                    {
                        AABB existingBounds = 
                        GetVoxelBounds(index);
                        for (auto& child : 
                        currentNode->children)
                        {
                            if (
                            IntersectAABBPoint(child->bounds, 
                            existingBounds.Center()))
                            {
                                child->objectIndices.
                                push_back(index);
                            }
                        }
                    }
                    currentNode->objectIndices.clear();
                }
            }

            bool foundChild = false;

            for (auto& child : currentNode->children)
            {
                if (IntersectAABBPoint(child->bounds, 
                objectBounds.Center()))
                {
                    currentNode = child;
                    foundChild  = true;
                    break;
                }
            }

            if (!foundChild)
            {
                currentNode->objectIndices.
                push_back(objectIndex);
                return;
            }
        }
    }

    float GetVoxelSize() const
    {
        return (rootBounds.max.x - rootBounds.min.x) / 
        (float)(gridSize * 2.0f);
    }

    bool IsTight() const
    {
        VERIFY_EXPR(isLeaf);

        double exp  = 1.0 / 3.0;
        double base = maxObjectsPerLeaf;

        float  boundDimension         = 
        (bounds.max.x - bounds.min.x);
        double overfullVoxelDimension = 
        std::ceil((GetVoxelSize() * 2) * pow(base, exp));

        return boundDimension <= overfullVoxelDimension;
    }

    bool IsLeafAndTight() const
    {
        if (!isLeaf) return false;

        return IsTight();
    }

    bool IsFull() const
    {
        if (IsLeafAndTight() && 
        objectIndices.size() >= maxObjectsPerLeaf)
        {
            return true;
        }
        else if (isLeaf)
        {
            return false;
        }
        else if (!isLeaf)
        {
            for (auto* child : children)
            {
                VERIFY_EXPR(child != nullptr);

                if (!child->IsFull())
                    return false;
            }

            return true;
        }

        VERIFY_EXPR(false);
 
        return false;
    }
};
\end{lstlisting}

% - octree.cpp
\begin{lstlisting}
#include "octree.h"

std::vector<AABB> OTVoxelBoundBuffer;

AABB GetVoxelBounds(size_t index)
{
    return OTVoxelBoundBuffer.at(index);
}

bool IntersectAABBAABB(const AABB& first, const AABB& second)
{
    return (first.min.x <= second.max.x && 
        first.max.x >= second.min.x) &&
        (first.min.y <= second.max.y && 
        first.max.y >= second.min.y) &&
        (first.min.z <= second.max.z && 
        first.max.z >= second.min.z);
}

bool IntersectAABBPoint(const AABB& first, 
const DirectX::XMFLOAT3& second)
{
    return 
        (second.x >= first.min.x && second.x <= first.max.x) &&
        (second.y >= first.min.y && second.y <= first.max.y) &&
        (second.z >= first.min.z && second.z <= first.max.z);
}
\end{lstlisting}

% - draw task
\begin{lstlisting}
#pragma once

#include <DirectXMath.h>
#include <BasicMath.hpp>

namespace VoxelOC
{
    struct OctreeLeafNode
    {
        DirectX::XMFLOAT4 BasePosAndScale;
        DirectX::XMFLOAT4 RandomValue;

        int VoxelBufStartIndex;
        int VoxelBufIndexCount;

        int Padding[2];

        bool operator==(OctreeLeafNode& other)
        {
            return BasePosAndScale.x == other.BasePosAndScale.x
                && BasePosAndScale.y == other.BasePosAndScale.y
                && BasePosAndScale.z == other.BasePosAndScale.z;
        }
    };

    struct DepthPrepassDrawTask
    {
        DirectX::XMFLOAT4 BasePositionAndScale;
        int               BestOccluderCount;
        int               Padding[3];

        DepthPrepassDrawTask() = default;

        DepthPrepassDrawTask(DepthPrepassDrawTask&& other) 
        noexcept
            :
            BasePositionAndScale(other.BasePositionAndScale),
            BestOccluderCount(other.BestOccluderCount)
        { }
    };

    struct VoxelBufData
    {
        DirectX::XMFLOAT4 BasePosAndScale;
    };
}

struct Vec4
{
    float x, y, z, w;
    
    Vec4() = default;

    Vec4(float x, float y, float z, float w) : 
        x(x), y(y), z(z), w(w)
        { }

    Vec4(Diligent::float4& other)
    {
        x = other.x;
        y = other.y;
        z = other.z;
        w = other.w;
    }

    bool operator<(const Vec4& other) const
    {
        if (x != other.x)
            return x < other.x;

        if (y != other.y)
            return y < other.y;

        if (z != other.z)
            return z < other.z;


        return false;
    }

    bool operator==(const Vec4& other) const
    {
        return x == other.x && y == other.y 
        && z == other.z && w == other.w;
    }
};

\end{lstlisting}

% - create draw tasks from mesh 
\begin{lstlisting}
    void Tutorial20_MeshShader::CreateDrawTasksFromMesh(
        std::string meshPath)
    {    
        PopulateOctree(meshPath);
        
        std::vector<VoxelOC::VoxelBufData>  
        orderedVoxelDataBuffer{};
        orderedVoxelDataBuffer.reserve(
            OTVoxelBoundBuffer.size());
        
        std::vector<VoxelOC::OctreeLeafNode> OTLeafNodes{};
        OTLeafNodes.reserve(
            static_cast<int>(OTVoxelBoundBuffer.size() / 2.0f));

        std::vector<VoxelOC::DepthPrepassDrawTask> 
        depthPrepassOTNodes;
        depthPrepassOTNodes.reserve(OTLeafNodes.size());
        
        OTVoxelBoundBuffer.clear();
        FastRandReal<float> Rnd{0, 0.f, 1.f};

        for (auto& task : OTLeafNodes)
        {
            task.RandomValue.x = Rnd();
            task.RandomValue.y = 0;
            task.RandomValue.z = 0;
        }

        for (auto& task : depthPrepassOTNodes)
        {
            task.BestOccluderCount = 
            static_cast<int>(depthPrepassOTNodes.size());
        }

        BindSortedIndexBuffer(orderedVoxelDataBuffer);
        BindOctreeNodeBuffer(OTLeafNodes);
        BindBestOccluderBuffer(depthPrepassOTNodes);
        
        m_DrawTaskCount = 
        static_cast<Uint32>(OTLeafNodes.size());

        m_DepthPassDrawTaskCount = 
        static_cast<Uint32>(depthPrepassOTNodes.size());
    }
\end{lstlisting}

% - populate octree node
\begin{lstlisting}
void Tutorial20_MeshShader::PopulateOctree(
    std::string OTmodelPath)
{
    BinvoxData data = read_binvox(OTmodelPath);

    size_t hierarchyDepth  = 0;
    AABB worldBounds       = {{0, 0, 0}, 
    {(float)data.width, (float)data.height, (float)data.depth}};
    m_pOcclusionOctreeRoot = 
    new OctreeNode<VoxelOC::OctreeLeafNode>(
        worldBounds, OTVoxelBoundBuffer, 
        (size_t)(worldBounds.max.x - worldBounds.min.x), 
        worldBounds, hierarchyDepth, -1, ASGroupSize);

    for (int z = 0; z < data.depth; ++z)
    {
        for (int y = 0; y < data.height; ++y)
        {
            for (int x = 0; x < data.width; ++x)
            {
                size_t index = get_index(x, y, z, data);
                if (data.voxels[index] > 0)
                {
                    AABB voxelBounds = 
                    {{(float)x, (float)y, (float)z}, 
                    {x + 1.f, y + 1.f, z + 1.f}};
                    OTVoxelBoundBuffer.push_back(
                        std::move(voxelBounds));
                    m_pOcclusionOctreeRoot->InsertObject(
                        OTVoxelBoundBuffer.size() - 
                        1, voxelBounds);
                }
            }
        }
    }
}
\end{lstlisting}

% - bind sorted index buffer
\begin{lstlisting}
void Tutorial20_MeshShader::BindSortedIndexBuffer(
    std::vector<VoxelOC::VoxelBufData>& orderedVoxelDataBuffer)
{
    BufferDesc BuffDesc;
    BuffDesc.Name = "Ordered voxel data buffer";
    BuffDesc.Usage = USAGE_DEFAULT;
    BuffDesc.BindFlags = BIND_SHADER_RESOURCE;
    BuffDesc.Mode = BUFFER_MODE_STRUCTURED;
    BuffDesc.ElementByteStride = 
    sizeof(orderedVoxelDataBuffer[0]);
    BuffDesc.Size = 
    sizeof(orderedVoxelDataBuffer[0]) * 
    static_cast<Uint32>(
        orderedVoxelDataBuffer.size());

    BufferData BufData;
    BufData.pData    = orderedVoxelDataBuffer.data();
    BufData.DataSize = BuffDesc.Size;

    m_pDevice->CreateBuffer(BuffDesc, &BufData, 
    &m_pVoxelPosBuffer);
    VERIFY_EXPR(m_pVoxelPosBuffer != nullptr);
}
\end{lstlisting}

% - bind octree node buffer
\begin{lstlisting}
void Tutorial20_MeshShader::BindOctreeNodeBuffer(
    std::vector<VoxelOC::OctreeLeafNode>& octreeNodeBuffer)
{
    octreeNodeBuffer.resize(octreeNodeBuffer.size() + 
    ASGroupSize - (octreeNodeBuffer.size() % ASGroupSize));
    VERIFY_EXPR(octreeNodeBuffer.size() % ASGroupSize == 0);

    BufferDesc BuffDesc;
    BuffDesc.Name              = "Octree node buffer";
    BuffDesc.Usage             = USAGE_DEFAULT;
    BuffDesc.BindFlags         = BIND_SHADER_RESOURCE;
    BuffDesc.Mode              = BUFFER_MODE_STRUCTURED;
    BuffDesc.ElementByteStride = sizeof(octreeNodeBuffer[0]);
    BuffDesc.Size              = sizeof(octreeNodeBuffer[0]) * 
    static_cast<Uint32>(octreeNodeBuffer.size());

    BufferData BufData;
    BufData.pData    = octreeNodeBuffer.data();
    BufData.DataSize = BuffDesc.Size;

    m_pDevice->CreateBuffer(BuffDesc, &BufData, 
    &m_pOctreeNodeBuffer);
    VERIFY_EXPR(m_pOctreeNodeBuffer != nullptr);
}
\end{lstlisting}

% - bind best occluder buffer
\begin{lstlisting}
void Tutorial20_MeshShader::BindBestOccluderBuffer(
    std::vector<VoxelOC::DepthPrepassDrawTask>& 
    depthPrepassOTNodes)
{
    if (depthPrepassOTNodes.size() == 0) return;

    // Realign deoth prepass octree node buffer
    depthPrepassOTNodes.resize(depthPrepassOTNodes.size() + 
    ASGroupSize - (depthPrepassOTNodes.size() % ASGroupSize));
    VERIFY_EXPR(depthPrepassOTNodes.size() % ASGroupSize == 0);

    BufferDesc BuffDesc;
    BuffDesc.Name              = "Best occluder nodes buffer";
    BuffDesc.Usage             = USAGE_DEFAULT;
    BuffDesc.BindFlags         = BIND_SHADER_RESOURCE;
    BuffDesc.Mode              = BUFFER_MODE_STRUCTURED;
    BuffDesc.ElementByteStride = sizeof(depthPrepassOTNodes[0]);
    BuffDesc.Size = sizeof(depthPrepassOTNodes[0]) * 
    static_cast<Uint32>(depthPrepassOTNodes.size());

    BufferData BufData;
    BufData.pData    = depthPrepassOTNodes.data();
    BufData.DataSize = BuffDesc.Size;

    m_pDevice->CreateBuffer(BuffDesc, &BufData, 
    &m_pBestOccluderBuffer);
    VERIFY_EXPR(m_pBestOccluderBuffer != nullptr);
}
\end{lstlisting}

% - create hiz mip generation pipeline
\begin{lstlisting}
void Tutorial20_MeshShader::CreateHiZMipGenerationPipeline(
    Diligent::ShaderCreateInfo& ShaderCI)
{
    // Create compute pipeline state
    ComputePipelineStateCreateInfo 
    HiZPSOCreateInfo{};
    HiZPSOCreateInfo.PSODesc.Name = 
    "HiZ Generation PSO";
    HiZPSOCreateInfo.PSODesc.PipelineType = 
    PIPELINE_TYPE_COMPUTE;

    // Create HiZ Buffer compute shader resource
    RefCntAutoPtr<IShader> pCS;
    {
        ShaderCI.Desc.ShaderType = SHADER_TYPE_COMPUTE;
        ShaderCI.EntryPoint      = "main";
        ShaderCI.Desc.Name       = "HiZ Generation CS";
        ShaderCI.FilePath        = "generate_HiZ.hlsl";

        m_pDevice->CreateShader(ShaderCI, &pCS);
        VERIFY_EXPR(pCS != nullptr);
    }
    HiZPSOCreateInfo.pCS = pCS;

    BufferDesc CBDesc;
    CBDesc.Name           = "HiZ Constants";
    CBDesc.Size           = sizeof(HiZConstants);
    CBDesc.Usage          = USAGE_DYNAMIC;
    CBDesc.BindFlags      = BIND_UNIFORM_BUFFER;
    CBDesc.CPUAccessFlags = CPU_ACCESS_WRITE;

    m_pDevice->CreateBuffer(CBDesc, nullptr, 
    &m_pHiZConstantBuffer);
    VERIFY_EXPR(m_pHiZConstantBuffer);

    PipelineResourceLayoutDesc PRLDesc{};
    PRLDesc.DefaultVariableType = 
    SHADER_RESOURCE_VARIABLE_TYPE_DYNAMIC;

    ShaderResourceVariableDesc 
    shaderResourceVariableDesc[3];

    shaderResourceVariableDesc[0].Name = 
    "InputTexture";
    shaderResourceVariableDesc[0].ShaderStages = 
    SHADER_TYPE_COMPUTE;
    shaderResourceVariableDesc[0].Type = 
    SHADER_RESOURCE_VARIABLE_TYPE_DYNAMIC;
    shaderResourceVariableDesc[0].Flags = 
    SHADER_VARIABLE_FLAG_NONE;

    shaderResourceVariableDesc[1].Name = 
    "OutputTexture";
    shaderResourceVariableDesc[1].ShaderStages =
    SHADER_TYPE_COMPUTE;
    shaderResourceVariableDesc[1].Type         = 
    SHADER_RESOURCE_VARIABLE_TYPE_DYNAMIC;
    shaderResourceVariableDesc[1].Flags        = 
    SHADER_VARIABLE_FLAG_NONE;

    shaderResourceVariableDesc[2].Name         = 
    "Constants";
    shaderResourceVariableDesc[2].ShaderStages = 
    SHADER_TYPE_COMPUTE;
    shaderResourceVariableDesc[2].Type         = 
    SHADER_RESOURCE_VARIABLE_TYPE_DYNAMIC;
    shaderResourceVariableDesc[2].Flags        = 
    SHADER_VARIABLE_FLAG_NONE;

    PRLDesc.NumVariables = 
    _countof(shaderResourceVariableDesc);
    PRLDesc.Variables    = 
    &shaderResourceVariableDesc[0];

    HiZPSOCreateInfo.PSODesc.ResourceLayout = 
    PRLDesc;

    // Create compute pipeline state object
    m_pDevice->CreateComputePipelineState(
        HiZPSOCreateInfo, &m_pHiZComputePSO);
    VERIFY_EXPR(m_pHiZComputePSO != nullptr);

    m_pHiZComputePSO->CreateShaderResourceBinding(
        &m_pHiZComputeSRB, true);
    VERIFY_EXPR(m_pHiZComputeSRB != nullptr);
}
\end{lstlisting}

% - depth prepass
\begin{lstlisting}
void Tutorial20_MeshShader::DepthPrepass()
{
    m_pImmediateContext->SetPipelineState(
        m_pDepthOnlyPSO);
    m_pImmediateContext->CommitShaderResources(
        m_pDepthOnlySRB, 
        RESOURCE_STATE_TRANSITION_MODE_TRANSITION);

    // Set depth-stencil view
    auto* pDSV = m_pSwapChain->GetDepthBufferDSV();
    //m_pImmediateContext->SetRenderTargets(0, 
    nullptr, nullptr, RESOURCE_STATE_TRANSITION_MODE_NONE);
    m_pImmediateContext->SetRenderTargets(0, 
    nullptr, pDSV, RESOURCE_STATE_TRANSITION_MODE_TRANSITION);

    VERIFY_EXPR(m_DepthPassDrawTaskCount % ASGroupSize == 0);

    DrawMeshAttribs drawAttrs{m_DepthPassDrawTaskCount, 
    DRAW_FLAG_VERIFY_ALL};
    m_pImmediateContext->DrawMesh(drawAttrs);
    
    // Unset depth buffer when copying
    m_pImmediateContext->SetRenderTargets(
        0, nullptr, nullptr, 
        RESOURCE_STATE_TRANSITION_MODE_NONE);

    // Copy and store best occluder depth buffer
    CopyTextureAttribs storeDepthBufAttribs{};
    storeDepthBufAttribs.pSrcTexture = 
    m_pSwapChain->GetDepthBufferDSV()->GetTexture();
    storeDepthBufAttribs.pDstTexture = 
    m_pHiZPyramidTexture;
    storeDepthBufAttribs.SrcTextureTransitionMode = 
    RESOURCE_STATE_TRANSITION_MODE_TRANSITION;
    storeDepthBufAttribs.DstTextureTransitionMode = 
    RESOURCE_STATE_TRANSITION_MODE_TRANSITION;
    storeDepthBufAttribs.DstMipLevel              = 
    0;

    m_pImmediateContext->CopyTexture(storeDepthBufAttribs);

    GenerateHiZ();
}
\end{lstlisting}

% - create hiz texture
\begin{lstlisting}
void Tutorial20_MeshShader::CreateHiZTextures()
{
    if (m_pHiZPyramidTexture.RawPtr() != nullptr)
        m_pHiZPyramidTexture.Release();

    m_HiZMipUAVs.clear();

    const uint32_t BaseWidth  = 
    m_pSwapChain->GetDesc().Width;
    const uint32_t BaseHeight = 
    m_pSwapChain->GetDesc().Height;

    // Calculate the number of mip levels
    uint32_t MipLevelCount = 1 + 
    static_cast<uint32_t>(
        floor(log2((std::max)(BaseWidth, BaseHeight))));
    VERIFY_EXPR(MipLevelCount > 0);

    // Create texture resource
    TextureDesc HiZTexDesc;
    HiZTexDesc.Type      = RESOURCE_DIM_TEX_2D;
    HiZTexDesc.Width     = BaseWidth;
    HiZTexDesc.Height    = BaseHeight;
    HiZTexDesc.Format    = TEX_FORMAT_R32_FLOAT;
    HiZTexDesc.BindFlags = 
    BIND_SHADER_RESOURCE | BIND_UNORDERED_ACCESS;
    HiZTexDesc.Usage     = USAGE_DYNAMIC;
    HiZTexDesc.MipLevels = MipLevelCount;

    m_pDevice->CreateTexture(HiZTexDesc, nullptr, 
    &m_pHiZPyramidTexture);
    VERIFY_EXPR(m_pHiZPyramidTexture != nullptr);

    // Create UAVs and SRVs for each mip level
    m_HiZMipUAVs.resize(MipLevelCount);

    for (uint32_t mip = 0; mip < MipLevelCount; ++mip)
    {
        TextureViewDesc UAVDesc;
        UAVDesc.ViewType        = 
        TEXTURE_VIEW_UNORDERED_ACCESS;
        UAVDesc.TextureDim      = 
        RESOURCE_DIM_TEX_2D;
        UAVDesc.MostDetailedMip = 
        mip;
        UAVDesc.NumMipLevels    = 
        1;
        m_pHiZPyramidTexture->CreateView(
            UAVDesc, &m_HiZMipUAVs[mip]);
        VERIFY_EXPR(m_HiZMipUAVs[mip] != nullptr);
    }
    
    StateTransitionDesc HiZTexBarrier{};
    HiZTexBarrier.pResource = 
    m_pHiZPyramidTexture;
    HiZTexBarrier.OldState = 
    RESOURCE_STATE_UNKNOWN;
    HiZTexBarrier.NewState = 
    RESOURCE_STATE_SHADER_RESOURCE;
    HiZTexBarrier.Flags = 
    STATE_TRANSITION_FLAG_UPDATE_STATE;
    
    m_pImmediateContext->TransitionResourceStates(
        1, &HiZTexBarrier);

    if (m_pSRB != nullptr)
        m_pImmediateContext->CommitShaderResources(
            m_pSRB, RESOURCE_STATE_TRANSITION_MODE_TRANSITION);
}
\end{lstlisting}

% - generate hiz
\begin{lstlisting}
    void Tutorial20_MeshShader::GenerateHiZ()
{
    StateTransitionDesc HiZResourceBarrier;
    HiZResourceBarrier.pResource      = 
    m_pHiZPyramidTexture;
    HiZResourceBarrier.OldState       = 
    RESOURCE_STATE_COPY_DEST;
    HiZResourceBarrier.NewState       = 
    RESOURCE_STATE_UNORDERED_ACCESS;
    HiZResourceBarrier.TransitionType = 
    STATE_TRANSITION_TYPE_IMMEDIATE;
    HiZResourceBarrier.Flags          = 
    STATE_TRANSITION_FLAG_UPDATE_STATE;
    m_pImmediateContext->TransitionResourceStates(
        1, &HiZResourceBarrier);

    // Set pipeline state and commit shader resources
    m_pImmediateContext->SetPipelineState(m_pHiZComputePSO);
    m_pImmediateContext->CommitShaderResources(
    m_pHiZComputeSRB, RESOURCE_STATE_TRANSITION_MODE_VERIFY);

    const auto& TexDesc = m_pHiZPyramidTexture->GetDesc();

    static uint32_t ThreadGroupSize = 32;

    for (Uint32 mipLevel = 1; 
    mipLevel < TexDesc.MipLevels; ++mipLevel)
    {
        uint32_t InputWidth   = 
        (std::max)(TexDesc.Width >> (mipLevel - 1), 1u);
        uint32_t InputHeight  = 
        (std::max)(TexDesc.Height >> (mipLevel - 1), 1u);
        uint32_t OutputWidth  = 
        (std::max)(TexDesc.Width >> mipLevel, 1u);
        uint32_t OutputHeight = 
        (std::max)(TexDesc.Height >> mipLevel, 1u);

        uint32_t GroupsX = 
        (OutputWidth + ThreadGroupSize - 1) / ThreadGroupSize;
        uint32_t GroupsY = 
        (OutputHeight + ThreadGroupSize - 1) / ThreadGroupSize;
        
        // Early exit when GroupsX or GroupsY become 0
        if ((std::max)(GroupsX, GroupsY) == 0) break;

        // Update const buffer data and map data to GPU memory
        {
            MapHelper<HiZConstants> Constants(
                m_pImmediateContext, m_pHiZConstantBuffer, 
                MAP_WRITE, MAP_FLAG_DISCARD);
            Constants->InputDimensions  = 
            uint2(InputWidth, InputHeight);
            Constants->OutputDimensions = 
            uint2(OutputWidth, OutputHeight);
            Constants->Level = mipLevel;
        }
        
         // Set the input and  output shader resources
        m_pHiZComputeSRB->GetVariableByName(
            SHADER_TYPE_COMPUTE, "InputTexture")->Set(
                m_HiZMipUAVs[mipLevel - 1]);
        m_pHiZComputeSRB->GetVariableByName(
            SHADER_TYPE_COMPUTE, "Constants")->Set(
                m_pHiZConstantBuffer);
        m_pHiZComputeSRB->GetVariableByName(
            SHADER_TYPE_COMPUTE, "OutputTexture")->Set(
                m_HiZMipUAVs[mipLevel]);

        m_pImmediateContext->CommitShaderResources(
            m_pHiZComputeSRB, 
            RESOURCE_STATE_TRANSITION_MODE_TRANSITION);

        // Dispatch compute shader
        DispatchComputeAttribs dispatchAttribs(
            GroupsX, GroupsY, 1);
        m_pImmediateContext->DispatchCompute(
            dispatchAttribs);
    }

    // Transition to unordered access
    StateTransitionDesc HiZResourceBarrier2;
    HiZResourceBarrier2.pResource      = 
    m_pHiZPyramidTexture;
    HiZResourceBarrier2.OldState       = 
    RESOURCE_STATE_UNKNOWN;
    HiZResourceBarrier2.NewState       = 
    RESOURCE_STATE_UNORDERED_ACCESS;
    HiZResourceBarrier2.TransitionType = 
    STATE_TRANSITION_TYPE_IMMEDIATE;
    HiZResourceBarrier2.Flags          = 
    STATE_TRANSITION_FLAG_UPDATE_STATE;
    m_pImmediateContext->TransitionResourceStates(
        1, &HiZResourceBarrier2);
    m_pImmediateContext->CommitShaderResources(
    m_pHiZComputeSRB, RESOURCE_STATE_TRANSITION_MODE_VERIFY);
}
\end{lstlisting}

% - render
\begin{lstlisting}
    void Tutorial20_MeshShader::Render()
    {
        renderTimer.Restart();
        auto* pRTV = m_pSwapChain->GetCurrentBackBufferRTV();
        auto* pDSV = m_pSwapChain->GetDepthBufferDSV();
        // Clear the back buffer and depth buffer
        //const float ClearColor[] = 
        {0.350f, 0.350f, 0.350f, 1.0f};
        const float ClearColor[] = 
        {0.05f, 0.05f, 0.05f, 1.0f};
        
        m_pImmediateContext->SetRenderTargets(
            1, &pRTV, pDSV, 
            RESOURCE_STATE_TRANSITION_MODE_TRANSITION);

        m_pImmediateContext->ClearRenderTarget(
            pRTV, ClearColor, 
            RESOURCE_STATE_TRANSITION_MODE_TRANSITION);
        m_pImmediateContext->ClearDepthStencil(
            pDSV, CLEAR_DEPTH_FLAG, 1.0f, 0, 
            RESOURCE_STATE_TRANSITION_MODE_TRANSITION);

        // Reset statistics
        DrawStatistics stats;
        std::memset(&stats, 0, sizeof(stats));
        m_pImmediateContext->UpdateBuffer(
            m_pStatisticsBuffer, 0, sizeof(stats), 
            &stats, RESOURCE_STATE_TRANSITION_MODE_TRANSITION);
    
        {
            MapHelper<Constants> CBConstants
            (m_pImmediateContext, m_pConstants, 
            MAP_WRITE, MAP_FLAG_DISCARD);
            CBConstants->ViewMat        = 
            m_ViewMatrix.Transpose();
            CBConstants->ViewProjMat    = 
            m_ViewProjMatrix.Transpose();

            CBConstants->DepthBias      = 
            m_OCThreshold;
            
            CBConstants->RenderOptions = 0;
            CBConstants->RenderOptions |= 
            (m_CullMode << 0);
            CBConstants->RenderOptions |= 
            ((m_OcclusionCulling ? 1 : 0) << 1);
            CBConstants->RenderOptions |= 
            ((m_FrustumCulling ? 1 : 0) << 2);
            CBConstants->RenderOptions |= 
            ((m_ShowOnlyBestOccluders ? 1 : 0) << 3);
            CBConstants->RenderOptions |= 
            ((m_UseLight ? 1 : 0) << 4);
            CBConstants->RenderOptions |= 
            ((m_MSDebugViz ? 1 : 0) << 5);
            CBConstants->RenderOptions |= 
            ((m_OTDebugViz ? 1 : 0) << 6);

            if (m_SyncCamPosition)
                ExtractViewFrustumPlanesFromMatrix(
                    m_ViewProjMatrix, Frustum, false);
    
            // Each frustum plane must be normalized.
            for (uint i = 0; 
            i < _countof(CBConstants->Frustum); ++i)
            {
                Plane3D plane  = Frustum.GetPlane(
                    static_cast<ViewFrustum::PLANE_IDX>(i));
                float   invlen = 1.0f / length(plane.Normal);
                plane.Normal *= invlen;
                plane.Distance *= invlen;
    
                CBConstants->Frustum[i] = plane;
            }

            DepthPrepass();

            m_pImmediateContext->SetRenderTargets(
                0, nullptr, pDSV, 
                RESOURCE_STATE_TRANSITION_MODE_TRANSITION);
            m_pImmediateContext->ClearDepthStencil(
                pDSV, CLEAR_DEPTH_FLAG, 1.0f, 0, 
                RESOURCE_STATE_TRANSITION_MODE_TRANSITION);
        }        

        // Reset pipeline state to normally draw to back buffer
        m_pImmediateContext->SetPipelineState(m_pPSO);

        m_pSRB->GetVariableByName(SHADER_TYPE_AMPLIFICATION, 
        "HiZPyramid")->Set(m_pHiZPyramidTexture->
        GetDefaultView(TEXTURE_VIEW_SHADER_RESOURCE));
        
        
        m_pImmediateContext->UpdateTexture(m_pOverdrawTexture, 
        0, 0, overdrawUpdateBox, subResData, 
            RESOURCE_STATE_TRANSITION_MODE_TRANSITION, 
            RESOURCE_STATE_TRANSITION_MODE_TRANSITION);
        m_pImmediateContext->CommitShaderResources(m_pSRB, 
        RESOURCE_STATE_TRANSITION_MODE_TRANSITION);
        m_pImmediateContext->SetRenderTargets(1, &pRTV, 
        pDSV, RESOURCE_STATE_TRANSITION_MODE_TRANSITION);


        VERIFY_EXPR(m_DrawTaskCount % ASGroupSize == 0);
    
        DrawMeshAttribs drawAttrs{m_DrawTaskCount, 
        DRAW_FLAG_VERIFY_ALL};
        m_pImmediateContext->DrawMesh(drawAttrs);
    
        // Copy statistics to staging buffer
        {
            m_VisibleCubes = 0;
    
            m_pImmediateContext->CopyBuffer(m_pStatisticsBuffer, 
            0, RESOURCE_STATE_TRANSITION_MODE_TRANSITION,
            m_pStatisticsStaging, static_cast<Uint32>(
                m_FrameId % m_StatisticsHistorySize) * 
                sizeof(DrawStatistics), sizeof(DrawStatistics),
            RESOURCE_STATE_TRANSITION_MODE_TRANSITION);
    
            m_pImmediateContext->EnqueueSignal(
                m_pStatisticsAvailable, m_FrameId);
    
            // Read statistics from previous frame.
            Uint64 AvailableFrameId = 
            m_pStatisticsAvailable->GetCompletedValue();
    
            // Synchronize
            if (m_FrameId - AvailableFrameId > 
            m_StatisticsHistorySize)
            {
                AvailableFrameId = m_FrameId - 
                m_StatisticsHistorySize;
                m_pStatisticsAvailable->Wait(
                    AvailableFrameId);
            }
    
            // Read the staging data
            if (AvailableFrameId > 0)
            {
                MapHelper<DrawStatistics> 
                StagingData(m_pImmediateContext, 
                m_pStatisticsStaging, MAP_READ, 
                MAP_FLAG_DO_NOT_WAIT);
                if (StagingData)
                {
                    m_VisibleCubes   = 
                    StagingData[AvailableFrameId % 
                    m_StatisticsHistorySize].visibleCubes;
                    m_VisibleOTNodes = 
                    StagingData[AvailableFrameId % 
                    m_StatisticsHistorySize].visibleOctreeNodes;
                }
            }

            m_pImmediateContext->SetRenderTargets(0, nullptr, 
            nullptr, RESOURCE_STATE_TRANSITION_MODE_NONE);
            m_pImmediateContext->Flush();
            m_pImmediateContext->FinishFrame();
            
            ++m_FrameId;
        }

        frameRenderTimes.push_back(
            renderTimer.GetElapsedTime());
    }
\end{lstlisting}