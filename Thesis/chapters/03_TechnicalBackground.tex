\chapter{Technical Background} \label{cpt-technical-background}


    
\section{Mesh Shading} \label{sec-mesh-shading}

% @TODO: Mention that this is rasterization pipeline!

Mesh Shaders were first introduced to nVidia Touring \ac{GPU}s in 2018 as a part of
"a new programmable geometric shading pipeline" and build upon the compute programming 
pipeline \cite[Christoph Kubisch]{Kubisch2018}. Therefore, they aim to optimize work by 
using the available hardware more efficiently. This section breaks down the differences 
of the Mesh Shading Pipeline compared to the traditional Vertex Shading Pipeline. In order 
to evaluate these differences effectively, we start by having a closer look at the 
Vertex Shading Pipeline.

\section{The Vertex Shading Pipeline} \label{sec-vertex-shading-pipeline}

The term \emph{Vertex Shading Pipeline} refers to the traditional rendering pipeline, which 
describes the different steps of the creation of a final output image, generated by the 
computer. Central to this pipeline are two \ac{GPU} programs, called \emph{Shaders}. The 
\emph{Vertex Shader} operates on the vertices of a given 3D model representation. 
The \emph{Pixel Shader} (also referred to as \emph{Fragment Shader}) operates on each pixel 
of the output frame buffer. Usually, the color values are calculated here, based on factors 
like light direction, camera position et cetera. \\

\begin{figure}[h]
    \centering
    \includegraphics[width=\linewidth]{images/graphics/traditional-rendering-pipeline.png}
    \caption{The traditional rendering pipeline as presented by nVidia in \cite[Christoph Kubisch]{Kubisch2018}.}
    \label{fig:traditional-rendering-pipeline}
\end{figure}

\noindent
The traditional rendering pipeline consists of several fix, programmable and optional steps.
Figure \ref{fig:traditional-rendering-pipeline} shows these steps and their execution order. 
This pipeline represents more or less what the rendering pipeline has been for years up to this point. 
It is still used in most real time applications to this day, and even the mentioned Mesh Shading 
Pipeline relies on some of the central steps of this pipeline. To render a given scene, the relevant 
scene data is aggregated and passed to the \ac{GPU} for processing. For the purpose of this case study 
we are going to focus on the two main shader programs, as mentioned above. \\

% @TODO: Explain vertex data layout (indexed vertexlist) before! This is important for meshlets later!
% @TODO: Find sources for this and double check its validity!

\noindent
The \emph{Vertex Shader} takes the vertices of the given meshes in the scene as an input, aswell as 
some global and vertex specific data. The per-vertex data can include arbitrary data like color values, 
texture coordinates, transformations or the associated normal vector. The global data, which can be shared
by all the pipelines programs, can include data like a progressing time value or the position of the camera.
The vertex shader is called by the \emph{Input Assembler Stage} (called \emph{Vertex Attribute Fetch} in 
Figure \ref{fig:traditional-rendering-pipeline}) which implicitly invokes the vertex shader for each vertex 
of the mesh. This means that the computational cost increases with the amount of (visible) vertices in the scene. 
There are efforts to optimize the input data both on the \ac{CPU} and the \ac{GPU} which are addressed in section 
\ref{sec-differences-and-comparison}. Since the Vertex Shader is a programmable pipeline stage, it can run  % @TODO: Check if this ref is still valid later!
custom code and operate in very different ways. Usually the Vertex Shader transforms the vertices in 3D 
euclidian space so they represent the correct positions relative to the scenes origin. \\

\noindent
After the Vertex Shader, the optional \emph{Tesselation Stage} can be executed. 
For instance, the Tesselation Stage can increase geometric resolution or triangulate polygonal geometry by 
applying tesselation functions. \\

\noindent
The \emph{Geometry Shader} is another optional pipeline stage. It is capable of generating additional primitives 
on the GPU. However, it is commonly said to be not very efficient and is treated as deprecated since the Introduction 
of the more general purpose and faster \emph{Compute Shaders}. \\ % @TODO: Check if this is correct and find sources

\noindent
The three-dimensional scene is then processed by the \emph{Rasterizer} which breaks down the scene description into 
a discrete, two-dimensional "image". This final image, also called \emph{Frame Buffer}, contains the two-dimensional 
projection of the scene from the cameras point of view. This rasterization process also implies creating discrete 
samples from continuous lines and faces. \\

\noindent
Finally, the final frame buffer is colored correctly by the \emph{Pixel Shader}. This stage takes all given parameters 
like light position, light color, light intensity, camera position, vertex colors, textures and many more into account 
and creates a final image. The pixel shader can implement different functions (\ac{BRDF}) for calculation of the final pixel color 
and is called once per pixel. This means, that the computational cost increases with the amount of pixel, i.e. the frame 
buffers resolution. \\




% @TODO: Explain every step of the pipeline ? 

% @TODO: Show input and output data of the Vertex Shader

% @TODO: What do I wanna say here?

% Good or even better to show evolution of rendering? -> Vertex Shaded Immediate Rendering -> 
% Vertex Shaded Deferred Rendering -> Mesh Shaded Deferred Rendering ? 

\section{The Mesh Shading Pipeline} \label{sec-mesh-shading-pipeline}

% @TODO: Mesh Shading Rendering Pipeline

\begin{figure}[h]
    \centering
    \includegraphics[width=\linewidth]{images/graphics/mesh-rendering-pipeline.png}
    \caption{The mesh shading pipeline as presented by nVidia in \cite[Christoph Kubisch]{Kubisch2018}.}
    \label{fig:mesh-rendering-pipeline}
\end{figure}

The \emph{Mesh Shading Rendering Pipeline} is a new rendering pipeline, optimized for high geometrical 
density. It shares the Rasterizer and the Pixel Shader stages with the "Traditional Rendering Pipeline" but 
introduces two new stages which aim to replace the Vertex Shader, Geometry Shader and Tesselation stage.
The new stages are called \emph{Task Shader} (or \emph{Amplification Shader}) and \emph{Mesh Shader}. Both 
are fully programmable and are based on the Compute Shader architecture. Therefore they are inherently different 
from the traditional Vertex Shader stage, even though they both can be used for vertex transformations.
Figure \ref{fig:mesh-rendering-pipeline} shows the piepline stages and the order they are executed in. \\

\noindent
The \emph{Task Shader} serves as a precomputational stage which is optional and invokes the \emph{Mesh Shader}.
The Task Shader can take any arbitrary data as input and operates on the data to produce output data which in 
turn is scheduled for execution on the Mesh Shader. Since both shaders are based on Compute Shaders, a thread 
group size can be specified and groupshared memory can be allocated. This allows for highly parallelized execution 
and optimized memory usage. The Mesh Shader output can be defined individually but usually creates a small patch 
consisting of a small number of triangles, called \emph{Meshlet}. This new approach to operating on vertices 
allows for a new interpretation of mesh data. Therefore, it is necessary to take a look at the data structure of 
meshes and how they translate to the Mesh Shading Pipeline. 

\subsection{Mesh Datastructure} \label{subsec-mesh-datastructure}



% @TODO: Discuss mesh data structure

% @TODO: What are Mesh Shaders?


% @TODO: What are they good for?
% @TODO: How does the pipeline differ from the Vertex Shader Pipeline?

% @TODO: Meshlet Culling algorithm here or in 06_CaseStudy.tex?

\subsection{Differences and Comparison} \label{sec-differences-and-comparison}

- Differences and performance benefits
- Maybe explain overdraw, pixel discard and other optimization techniques like culling, early z-testing, ...

\subsubsection{Task/Amplification Shader} \label{subsec-task-shader}

- Task shader and mesh shader invocation % @TODO: Check how this compares to vertex transformation subsection

\subsubsection{Vertex Transformation} \label{subsec-vertex-transformation}

- Vertex Shader vs. Mesh Shader in geometry creation, vertex transformation and early exit
- Allows for denser geometry 
- New data input layout + compute and groupshared memory

\section{Culling} \label{subsec-culling}

- What is culling and why is it important?

\subsection{View Frustum Culling} \label{subsubsec-view-frustum-culling}

- View frustum culling

\subsection{Occlusion Culling} \label{subsubsec-occ-culling}

- Occlusion Culling and approaches

\subsection{Meshlet Occlusion Culling} \label{subsubsec-meshlet-occ-culling}

- Meshlet Occlusion culling, benefits and effect on data and invocations

% @TODO: Meshlet Creation

