\chapter{Experiment} \label{cpt-experiment}

When considering occlusion culling algorithms that can be used in a given use case, the runtime 
performance is a critical aspect. But runtime performance is a multi-dimensional measure, in that 
most algorithms provide given results under specific circumstances and by setting several constraints.
To be able to evaluate the strengths and weaknesses of the given implementation, an in-depth  
experiment was conducted and evaluated, highlighting a diverse set of measured data. \\ 

\noindent
The method of profiling performance was chosen because 

\section{Experimental Evaluation} \label{sec-experimental-evaluation}

To evaluate the key differences and the runtime performance in general, several aspects had to be considered.
Unfortunatly, comparing the occlusion culling implementation to an alternative implementation was not within the 
scope of this work, so efforts were made in order to evaluate the pipeline and its performance from a conceptual 
point of view and compared to the plain pipeline, without any occlusion culling at all. This includes two different 
versions of occlusion culling, one based on culling octree node as it can be implemented without the use of the 
Mesh Shading pipeline. The other one is based on per-meshlet occlusion culling, which makes use of the more parallel 
computation capabilities of the \ac{GPU}. \\

\noindent
This sections highlights the major aspects which were considered for the experiment and were evaluated during the 
test runs. All aspects aim to demonstrate how the occlusion culling affected the given test scene and how the 
computations differ compared to the plain pipeline. Later, use cases are considered which can be compared to 
alternative algorithms on a high level. However, keep in mind that it is up to future measurements to quantitavely 
compare the pipeline to alternative approaches. 


\subsection*{Scene Layout} \label{subsec-scene-layout}

Any occlusion culling algorithm somehow relies on spatial information, be it in world space, sceen space or by 
using a spatial container. Consequently, the scene layout and how the scene changes relative to the camera are 
important aspects to consider. For this experimental setup, a moving camera was used in order to test the ability 
of the occlusion culling algorithm to adapt to different angles of the scene. \\

\noindent
[@TODO: Consider replacing the last "algorithm" with the actual subelement of the algo (scene data / data dispatch / ...)] 
Another aspect to consider is the model data structure. The voxel models are volumetric representations and thus, 
not hollow. This leaves a large portion of computation to be irrelevant and allows for the occlusion culling to 
optimize the data flow. Different types of models were used to challenge the culling algorithm in different ways. 
In concept, the culling should be optimal on large, dense models with even faces. Consequently, models with 
slopes and holes were tested, to see how best occluders can be computed for diverse geometry. Smaller models might 
also pose a challenge for the optimization, especially when the octree nodes cannot be filled completely. Also, 
different voxle resolutions were used to achieve different amounts of octree nodes in the scene. All these different 
aspects aim to show the strengths and weaknesses of the algorithm and how it can be optimally used in practice. \\

\noindent
The resolution of the voxelization process played a central role in the experimentation process.
For the experiment, the voxel scenes were constrained to be a power of two in length per axis, and the following
scene resolutions were tested.

\begin{itemize}
    \item \begin{math} \emph{128} \times \emph{128} \times \emph{128}\end{math}, resulting in a maximum of \emph{2.097.152} voxels
    \item \begin{math} \emph{256} \times \emph{256} \times \emph{256}\end{math}, resulting in a maximum of \emph{16.777.216} voxels
    \item \begin{math} \emph{512} \times \emph{512} \times \emph{512}\end{math}, resulting in a maximum of \emph{134.217.728} voxels
\end{itemize}

\noindent
In practice, the maximum amount of voxels was limited by how the data is dispatched on the \ac{GPU}. In the 
implementation, the shader model used (HLSL Shader Model 6.6) was limited to a maximum amount of 65.536 
threadgroups. That means that the threadgroup size and the amount of constructed octree nodes influenced the 
possible resolutions of the scenes. This limitation can be overcome by scheduling more than one draw call, 
but for this experiment, only one draw call was used. Consequently, the actual maximum amount of voxels in the 
scene was around 3 - 4 million voxels, which was considered enough for this experiment.

[@TODO: Add images of all the models]


\subsection*{Timings} \label{subsec-timings}

Ultimately, the time spent for various computations is relevant for the selection of the best algorithm. This is 
a central tool to see how the implementation performs overall in the context of the framework used. The frame 
time is the first measurment to be considered, but not necessarily the most meaningful in a complex pipeline. 
Consequently, the timings for all major pipeline steps were considered, as well as the overall time spend on 
\ac{CPU} and \ac{GPU} computations. 


\subsection*{Visibility and Culling} \label{subsec-visibility-and-culling}

In order to evaluate the general functionality and effectiveness of the pipeline, the voxel model was analysed 
with and without the occlusion culling applied. The amount of culled voxels was compared to the total amount of 
voxels resulting in an overview of how much geometry could be culled for different scene setups. The same is 
valid for the amount of octree nodes. They could also be compared to the amount of best occluders. The more best 
occluders present in a scene, the higher the probability to occlude other voxels or octree nodes. To evaluate 
how much can be optimized during the depth pre pass, the amount of best occluders was compared to the amount 
of voxels representing the best occluders. \\

\noindent
Finally, the actual amount of processed triangles was considered in order to show the actual geometry processed 
by the \ac{GPU}. This data indicates how much work is being scheduled for the vertex transformations, the rasterizer 
and the pixel shader. Ultimately, it decides over the amount of overdraw and should therefore be kept at a minimum.


\subsection*{Additional Overhead} \label{subsec-additional-overhead}

[@TODO: Refresh sentence]
The additional overhead needs to be evaluated compared to the gain in performance by the occlusion culling. 
Because of that, the pipeline is analyzed and the timings are compared to a pipeline without the culling 
algorithm. All per-frame computations are evaluated to see how much resources are spent on culling overhead. 
The results are compared against the acceleration provided by the algorithm.\\

\noindent
To increase the significance of the data, the per-meshlet occlusion culling was compared against the 
per-octree occlusion culling. The difference should be able to show, how the Mesh Shading pipeline 
influences the culling algorithm. The per-meshlet culling was expected to be more precise and to cull 
more voxels, since individual voxels within one octree can be culled, as opposed to per-octree node 
culling, which either renders all voxels within an octree node or culls it completely. 


\subsection*{Measuring Tools} \label{subsec-measuring-tools}

To measure timings and data precisely, a few external tools were used. All tools are part of the industry 
standard and were therefore assumed to be mostly reliable. Still, measuring performance usally comes with 
a minimal overhead which means that the results most likely vary in precision. Also, some of the tools 
provided various ways of coming up with the data. Some data was measured while the profiled application 
was running, and other data was acquired by replaying the command list of the \ac{GPU}. Consequently, all 
measurements referring to one aspect of the application were compared against measurements using the same 
tool and configuration, if not explicitly specified otherwise. \\

\noindent
For the collection of data output, \emph{RenderDoc} \cite{RenderDoc} was used. It is a free, MIT licensed 
rendering debugger, widely used in the industy. For \emph{NVIDIA} specific \ac{GPU} profiling, \emph{NVIDIA NSight} 
\cite{NSight} was used, which is another industry standard profiling and debugging tool. It is only available for 
inspection of \emph{NVIDIA} graphics card computations but provided valuable insights into the rendering pipeline 
and hardware usage. The last tool used is \emph{Microsoft's PIX} \cite{PIX}, which is another performance debugging 
and profiling tool for \emph{Windows} platforms using \emph{Microsoft's DirectX} \ac{API}.


\subsection*{Experimental Environment} \label{subsec-experimental-environment}

For the experiment, different hardware setups were used to compare the runtime performance in different environments.
Some more modern hardware was used to profile the best case computations, and older hardware was used for the results 
to different versions of hardware features and capabilities.

\begin{table}[h]
    \begin{tabular}{|llll|}
        \hline
        \multicolumn{4}{|c|}{\textbf{Test setups}}                                                                                                               \\ \hline
        \multicolumn{1}{|l|}{}                     & \multicolumn{1}{l|}{\textbf{Setup 1}} & \multicolumn{1}{l|}{\textbf{Setup 2}}   & \textbf{Setup 3}          \\ \hline
        \multicolumn{1}{|l|}{\textbf{System Type}} & \multicolumn{1}{l|}{Desktop}          & \multicolumn{1}{l|}{Desktop}            & Laptop                    \\
        \multicolumn{1}{|l|}{\textbf{CPU}}         & \multicolumn{1}{l|}{AMD ...}          & \multicolumn{1}{l|}{AMD ...}            & Intel Ultra 7 155H        \\
        \multicolumn{1}{|l|}{\textbf{Cores}}       & \multicolumn{1}{l|}{x}                & \multicolumn{1}{l|}{x}                  & 16 (22)                   \\
        \multicolumn{1}{|l|}{\textbf{RAM}}         & \multicolumn{1}{l|}{x GB}             & \multicolumn{1}{l|}{x GB}               & 16 GB                     \\
        \multicolumn{1}{|l|}{\textbf{GPU}}         & \multicolumn{1}{l|}{NVIDIA RTX 4090}  & \multicolumn{1}{l|}{NVIDIA RTX 2080 Ti} & Intel Arc Graphics        \\
        \multicolumn{1}{|l|}{\textbf{VRAM}}        & \multicolumn{1}{l|}{x GB}             & \multicolumn{1}{l|}{x GB}               & 128 MB (+ 8972 MB shared) \\
        \multicolumn{1}{|l|}{\textbf{OS}}          & \multicolumn{1}{l|}{Windows 10}       & \multicolumn{1}{l|}{Windows 10}         & Windows 11                \\
        \multicolumn{1}{|l|}{\textbf{Model}}       & \multicolumn{1}{l|}{-}                & \multicolumn{1}{l|}{-}                  & ASUS Zenbook 14 (2024)    \\ \hline
    \end{tabular}
    \caption{The experimental setups used to profile the applications performance.}
    \label{tbl:hardware-setup}
\end{table}

\noindent
Note that the use of the Mesh Shading pipeline requires graphics cards that support the pipeline in the first place. 
For \emph{NVIDIA} \ac{GPU}s this is the \emph{Turing} lineup (\emph{NVIDIA RTX 20 series}) and for \emph{AMD} cards 
this would be the \emph{RDNA 2} lineup (\emph{AMD RX 6000 series}). \emph{Intel} \ac{GPU}s support the feature as 
well, starting from their first installment in the dedicated desktop \ac{GPU} series \emph{Intel Arc}. The specs of 
the test setups are listed in table \ref{tbl:hardware-setup}. \\


\subsection*{Models} \label{subsec-models}

\begin{figure}[h]
  \centering
  \includegraphics[width=80px]{images/graphics/model-lucy.jpg}
  \includegraphics[width=80px]{images/graphics/model-hairball.jpg}
  \includegraphics[width=80px]{images/graphics/model-bunny.jpg}
  \includegraphics[width=80px]{images/graphics/model-torus.jpg}
  \includegraphics[width=80px]{images/graphics/model-terrain.jpg}
  \caption{The models used for the experiment.}
  \label{fig:experiment-models}
\end{figure}

\noindent
The models that were used in the tests are \emph{Lucy} (Stanford 3D Scanning Repository), the \emph{Stanford Bunny} 
(Stanford 3D Scanning Repository), the \emph{Hairball}, a \emph{Torus} and a \emph{Terrain} scene. All of 
these models provide different characteristics, which tested the pipeline in a variety of ways. \\

\noindent
The \emph{Lucy} model is tall and slim, which means that its volume is distributed more over one axis 
than over the other two axis. This is assumed to provide interesting insights into how such an object 
self-occludes the voxels when viewed from different perspectives. It also has a few narrow parts where 
no best occluders are expected. \\

\noindent
For low resolutions, the \emph{Hairball} isn't voxelized enough to maintain all the thin and tiny details, 
but for higher resolutions, the small structures were assumed to be not sufficient in density to completely
fill octree nodes, resulting in an unfavorable data layout to test the limits of the mesh computations. \\

\noindent
The \emph{Stanford Bunny} is a large and dense model with a lot of voxels in any possible resolution.
It also has different features to it, one of them being the curved surface resulting in a lot of octree 
nodes not being filled completely. On the other hand, because of its large volume, the model is assumed 
to be efficient when rendering the best occluders, aggregating a lot of smaller octree nodes to larger 
approximations. \\ 

\noindent
The \emph{Torus} provides a higher voxel count and a hole in it, which created an area where the 
octree isn't densly filled with voxels. This model was specifically used to test the algorithm's 
capabilities of culling voxels, when the voxels were densly crowded in small parts of the scene, and 
at the same time provided areas with no voxels at all. Also, the \emph{Torus} is an inherently round 
shape and therefore has a lot of partially filled octree nodes representing its surface. \\

\noindent
The \emph{Terrain} model aimed to replicate a relatively flat, open area that could be found in actual 
games like \emph{Minecraft}. Its surface is setup in a way that allows for only a small amount of best 
occluders to be formed. The terrain's hills are assumed to be occluders which again would help for rendering 
such a scene in a game. \\

\noindent
Some of the data was sampled over time using a standardized camera animation, which was following a circular orbit 
around the model, visualized below. A vertical offset was added to the orbit, so the model was drawn from various 
angles. This was especially important for models like the \emph{Torus}, which are likely to behave very differently 
when viewed from above compared to when viewed from the side.

\begin{figure}[h]
    \centering
    \includegraphics[width=200px]{images/graphics/test-anim-camera-path.jpg}
    \caption{During profiling, the camera is moved along an orbit around the voxel mesh, while being offset to compensate 
    for models, which behave differently when viewed from an angle. The visualization is not to scale, the models 
    are always completely visible and not culled by view frustum culling.}
    \label{fig:test-anim-camera-path}
\end{figure}



%- Compare:
%    - Model turntable rendered without OC
%    - Model turntable rendered with OC
%(   - Model turntable rendered with different OC implementation (? -> hard))
%
%
%- Criteria: 
%    - Frame time
%    - Dispatch numbers (?)
%    - Duration of depth pre-pass
%        - Draw best occluders to depth buffer
%        - Duration of depth hierarchy creation
%    - Visible cubes
%    - Visible octree nodes
%    - Triangle count
%    - Amount of best occluders
%    - CPU time
%    - GPU time
%    - Amount of overdraw (heatmap if possible)
%
%
%- Model variations:
%    - Lucy
%    - Stanford Bunny
%    - Torus (for when objects have "holes")
%    - Some large, wide scenery
%    - Sponza        -> Ehrlich sein und T
%    - ...
%
%
%- Machines:
%    - Laptop
%    - RTX 2080 Ti
%    - RTX 4090
%    - Multiple devices


\section{Culling Results}

The amount of visible voxels compared to the amount of culled voxels is one major aspect of the 
experiment and is not related to the actual performance measures. They are assumed to be the same 
for all hardware setups and are therefore only measured on the \emph{Laptop} setup. The results are 
presented below, comparing the per-octree culling with the per-meshlet culling. For the culling, the 
profiling camera animation was used to provide better average values in a more realistic environment.\\


\subsection*{Stanford Lucy - $256^3$}

% --------------------------------------- LUCY 256 ---------------------------------------

\begin{figure}[h]              % Lucy 256 Voxels Test Anim
    \begin{center}
      \begin{tikzpicture}
        \begin{axis}[
            width=\linewidth, % Scale the plot to \linewidth
            height=100px,
            xlabel={Frames},
            ylabel={Visible Voxels},
            grid,
            xmin=0,
            xmax=2392,
            ymin=60000,
            ymax=160000
          ]
          \addplot[green, no marks, solid] table[col sep=comma, x=frame, y=visible_voxels]{./plotdata/lucy_256_voxels.csv};
          \addplot[blue, dotted, no marks, domain=0:2393, samples=50] {140842};
          \addplot[orange, no marks, solid] table[col sep=comma, x=frame, y=visible_voxels]{./plotdata/lucy_256_voxels_pmoc.csv};
          \addplot[red, dotted, no marks, domain=0:2393, samples=50] {84082};
        \end{axis}
      \end{tikzpicture}
      \caption{The amount of visible voxels over the course of the test animation shown in green for 
      per-octree occlusion culling, and in orange for per-meshlet occlusion culling. 
      The average amount of visible voxels was \emph{140,842} for per-octree occlusion culling, which is 
      marked as the blue dotted line, and \emph{84,082} for per-meshlet occlusion culling, marked in red.}
      \label{plt:lucy-256-culling-res-voxels}
    \end{center}
  \end{figure}


  \begin{figure}[h]            % Lucy 256 OT Nodes Test Anim
    \begin{center}
      \begin{tikzpicture}
        \begin{axis}[
            width=\linewidth, % Scale the plot to \linewidth
            height=100px,
            xlabel={Frames},
            ylabel={Visible Nodes},
            grid,
            xmin=0,
            xmax=2392,
            ymin=1800,
            ymax=4000
          ]
          \addplot[green, no marks, solid] table[col sep=comma, x=frame, x expr=\thisrow{frame} * 2392 / 2392, y=visible_nodes]{./plotdata/lucy_256_nodes.csv};
          \addplot[blue, dotted, no marks, domain=0:2393, samples=50] {3460};
          \addplot[orange, no marks, solid] table[col sep=comma, x=frame, x expr=\thisrow{frame} * 2392 / 2395, y=visible_nodes]{./plotdata/lucy_256_nodes_pmoc.csv};
          \addplot[red, dotted, no marks, domain=0:2393, samples=50] {2483};
        \end{axis}
      \end{tikzpicture}
      \caption{The amount of visible octree nodes over the course of the test animation shown in green for 
      per-octree occlusion culling and in orange for per-meshlet occlusion culling. 
      The average amount of visible octree nodes was \emph{3,460} for per-octree occlusion culling, which is 
      marked as the blue dotted line, and \emph{2,483} for per-meshlet occlusion culling, which is marked in 
      as the red dotted line.}
      \label{plt:lucy-256-culling-res-nodes}
    \end{center}
  \end{figure}

% ----------------------------------------------------------------------------------------

\noindent
Figures \ref{plt:lucy-256-culling-res-voxels} and \ref{plt:lucy-256-culling-res-nodes} show the 
amount of visible voxels and visible octree nodes for both the per-octree meshlet culling and the 
per-meshlet octree culling configuration. It is obvious that the per-meshlet culling significantly 
reduces the amount of dispatched voxels and octree nodes, which leads to less load for the rasterizer 
and the pixel shader. \\

\noindent
The amount of octree nodes decreases when using per-meshlet culling, because octree nodes can be culled,
even when their corners are visible by the camera. For instance, when considering a node that holds just 
5 voxels, which are all overlapped by a part of the model, this octree node will be inherently culled when 
using per-meshlet culling. Contrary, when using per-octree culling, the culling is dependant on the 
visibility of any of the octree nodes corners, which can result in a node being not culled, even though all 
voxels within that node remain occluded. \\

\noindent 
Both curves indicate how the model fits the overall culling algorithm. For instance, the \emph{Stanford Lucy} 
model has a relatively even curve over time. Of course, this is a dynamic measure and highly depends on the 
angle of the camera. Still, the compact, tall model provides a good amount of best occluders to occlude a 
relatively even number of voxels when viewed from the side. \\

\noindent
Considering the average amount of visible voxels, the per-octree algorithm was able to cull $57.5\%$ of all 
voxels. The per-meshlet culling even managed to ommit on average $74.6\%$ of all voxels. 



\subsection*{Stanford Bunny - $256^3$}


% --------------------------------------- BUNNY 256 --------------------------------------

\begin{figure}[h]              % Bunny 256 Voxels Test Anim
    \begin{center}
      \begin{tikzpicture}
        \begin{axis}[
            width=\linewidth, % Scale the plot to \linewidth
            height=100px,
            xlabel={Frames},
            ylabel={Visible Voxels},
            grid,
            xmin=0,
            xmax=1186,
            ymin=100000,
            ymax=500000
          ]
          \addplot[green, no marks, solid] table[col sep=comma, x=frame, x expr=\thisrow{frame} * 1186 / 1186, y=visible_voxels]{plotdata/bunny_256_voxels.csv};
          \addplot[blue, dotted, no marks, domain=0:1186, samples=50] {385210};
          \addplot[orange, no marks, solid] table[col sep=comma, x=frame, x expr=\thisrow{frame} * 1186 / 1490, y=visible_voxels]{plotdata/bunny_256_voxels_pmoc.csv};
          \addplot[red, dotted, no marks, domain=0:1186, samples=50] {180266};
        \end{axis}
      \end{tikzpicture}
      \caption{The amount of visible voxels over the course of the test animation shown in green for 
      per-octree occlusion culling, and in orange for per-meshlet occlusion culling. 
      The average amount of visible voxels was \emph{385,210} for per-octree occlusion culling, which is 
      marked as the blue dotted line, and \emph{180,266} for per-meshlet occlusion culling, marked in red.}
      \label{plt:bunny-256-culling-res-voxels}
    \end{center}
  \end{figure}

  \begin{figure}[h]            % Bunny 256 OT Nodes Test Anim
    \begin{center}
      \begin{tikzpicture}
        \begin{axis}[
            width=\linewidth, % Scale the plot to \linewidth
            height=100px,
            xlabel={Frames},
            ylabel={Visible Nodes},
            grid,
            xmin=0,
            xmax=1186,
            ymin=3000,
            ymax=10000
          ]
          \addplot[green, no marks, solid] table[col sep=comma, x=frame, x expr=\thisrow{frame} * 1186 / 1186, y=visible_nodes]{./plotdata/bunny_256_nodes.csv};
          \addplot[blue, dotted, no marks, domain=0:1186, samples=50] {8519};
          \addplot[orange, no marks, solid] table[col sep=comma, x=frame, x expr=\thisrow{frame} * 1186 / 1490, y=visible_nodes]{./plotdata/bunny_256_nodes_pmoc.csv};
          \addplot[red, dotted, no marks, domain=0:1186, samples=50] {5415};
        \end{axis}
      \end{tikzpicture}
      \caption{The amount of visible octree nodes over the course of the test animation shown in green for 
      per-octree occlusion culling and in orange for per-meshlet occlusion culling. 
      The average amount of visible octree nodes was \emph{8,519} for per-octree occlusion culling, which is 
      marked as the blue dotted line, and \emph{5,415} for per-meshlet occlusion culling, which is marked in 
      as the red dotted line.}
      \label{plt:bunny-256-culling-res-nodes}
    \end{center}
  \end{figure}
 
% ----------------------------------------------------------------------------------------

\noindent
Similar to the first model, the \emph{Stanford Bunny} also discards a significant amount of 
voxels in both of the applied culling configurations. The average culling ratio was $88.6\%$ 
for the per-octree occlusion culling, and $94.6\%$ for the per-meshlet culling. This immense 
amount of occlusion is due to the already large amount of \emph{3,379,738} total voxels in the 
mesh and the large volume of the model, which provides a good basis for the generation of best 
occluders. \\



\subsection*{Torus - $256^3$}

% --------------------------------------- TORUS 256 --------------------------------------

\begin{figure}[h]              % Torus 256 Voxels Test Anim
    \begin{center}
      \begin{tikzpicture}
        \begin{axis}[
            width=\linewidth, % Scale the plot to \linewidth
            height=100px,
            xlabel={Frames},
            ylabel={Visible Voxels},
            grid,
            xmin=0,
            xmax=1087,
            ymin=70000,
            ymax=500000
          ]
          \addplot[green, no marks, solid] table[col sep=comma, x=frame, x expr=\thisrow{frame} * 1087 / 1087, y=visible_voxels]{./plotdata/torus_256_voxels.csv};
          \addplot[blue, dotted, no marks, domain=0:1087, samples=50] {359313};
          \addplot[orange, no marks, solid] table[col sep=comma, x=frame, x expr=\thisrow{frame} * 1087 / 1845, y=visible_voxels]{./plotdata/torus_256_voxels_pmoc.csv};
          \addplot[red, dotted, no marks, domain=0:1087, samples=50] {170772};
        \end{axis}
      \end{tikzpicture}
      \caption{The amount of visible voxels over the course of the test animation shown in green for 
      per-octree occlusion culling, and in orange for per-meshlet occlusion culling. 
      The average amount of visible voxels was \emph{359,313} for per-octree occlusion culling, which is 
      marked as the blue dotted line, and \emph{170,772} for per-meshlet occlusion culling, marked in red.}
      \label{plt:torus-256-culling-res-voxels}
    \end{center}
  \end{figure}


  \begin{figure}[h]            % Torus 256 OT Nodes Test Anim
    \begin{center}
      \begin{tikzpicture}
        \begin{axis}[
            width=\linewidth, % Scale the plot to \linewidth
            height=100px,
            xlabel={Frames},
            ylabel={Visible Nodes},
            grid,
            xmin=0,
            xmax=1087,
            ymin=1000,
            ymax=10000
          ]
          \addplot[green, no marks, solid] table[col sep=comma, x=frame, x expr=\thisrow{frame} * 1087 / 1087, y=visible_nodes]{./plotdata/torus_256_nodes.csv};
          \addplot[blue, dotted, no marks, domain=0:1087, samples=50] {7712};
          \addplot[orange, no marks, solid] table[col sep=comma, x=frame, x expr=\thisrow{frame} * 1087 / 1845, y=visible_nodes]{./plotdata/torus_256_nodes_pmoc.csv};
          \addplot[red, dotted, no marks, domain=0:1087, samples=50] {4768};
        \end{axis}
      \end{tikzpicture}
      \caption{The amount of visible octree nodes over the course of the test animation shown in green for 
      per-octree occlusion culling and in orange for per-meshlet occlusion culling. 
      The average amount of visible octree nodes was \emph{7,712} for per-octree occlusion culling, which is 
      marked as the blue dotted line, and \emph{4,768} for per-meshlet occlusion culling, which is marked in 
      as the red dotted line.}
      \label{plt:torus-256-culling-res-nodes}
    \end{center}
  \end{figure}

% ----------------------------------------------------------------------------------------

\noindent
The \emph{Torus} model varied in culling efficiency depending on the view angle. As expected, the hole 
in the mesh turned out to be inefficient for the culling algorithm. When considering the occlusion ratio, 
both the per-octree occlusion culling and the oer-meshlet occlusion culling performed significantly better 
when the torus was viewed from an angle, occluding the hole in the middle. The variation between the maxium 
amount of visible voxels and the minimum amount of voxels was the highest for the \emph{Torus} model, which 
is remarkable compared to the other models. Using this particular experimental setup, the lowest amount of 
visible voxels was $36.8\%$ of the maximum amount of visible voxels. This variation is also clearly evident 
in figure \ref{plt:torus-256-culling-res-voxels}. \\ 

\noindent
In general, for per-octree culling, the average culling ratio was $84.4\%$, and $92.6\%$ for per-meshlet culling. 



\subsection*{Terrain - $256^3$}

% -------------------------------------- TERRAIN 256 -------------------------------------

\begin{figure}[h]              % Terrain 256 Voxels Test Anim
    \begin{center}
      \begin{tikzpicture}
        \begin{axis}[
            width=\linewidth, % Scale the plot to \linewidth
            height=100px,
            xlabel={Frames},
            ylabel={Visible Voxels},
            grid,
            xmin=0,
            xmax=1239,
            ymin=70000,
            ymax=500000
          ]
          \addplot[green, no marks, solid] table[col sep=comma, x=frame, x expr=\thisrow{frame} * 1239 / 1239, y=visible_voxels]{./plotdata/terrain_256_voxels.csv};
          \addplot[blue, dotted, no marks, domain=0:1239, samples=50] {396228};
          \addplot[orange, no marks, solid] table[col sep=comma, x=frame, x expr=\thisrow{frame} * 1239 / 1759, y=visible_voxels]{./plotdata/terrain_256_voxels_pmoc.csv};
          \addplot[red, dotted, no marks, domain=0:1239, samples=50] {180440};
        \end{axis}
      \end{tikzpicture}
      \caption{The amount of visible voxels over the course of the test animation shown in green for 
      per-octree occlusion culling, and in orange for per-meshlet occlusion culling. 
      The average amount of visible voxels was \emph{396,228} for per-octree occlusion culling, which is 
      marked as the blue dotted line, and \emph{180,440} for per-meshlet occlusion culling, marked in red.}
      \label{plt:terrain-256-culling-res-voxels}
    \end{center}
  \end{figure}


  \begin{figure}[h]            % Terrain 256 OT Nodes Test Anim
    \begin{center}
      \begin{tikzpicture}
        \begin{axis}[
            width=\linewidth, % Scale the plot to \linewidth
            height=100px,
            xlabel={Frames},
            ylabel={Visible Nodes},
            grid,
            xmin=0,
            xmax=1239,
            ymin=1000,
            ymax=10000
          ]
          \addplot[green, no marks, solid] table[col sep=comma, x=frame, x expr=\thisrow{frame} * 1239 / 1239, y=visible_nodes]{./plotdata/terrain_256_nodes.csv};
          \addplot[blue, dotted, no marks, domain=0:1239, samples=50] {8207};
          \addplot[orange, no marks, solid] table[col sep=comma, x=frame, x expr=\thisrow{frame} * 1239 / 1759, y=visible_nodes]{./plotdata/terrain_256_nodes_pmoc.csv};
          \addplot[red, dotted, no marks, domain=0:1239, samples=50] {3832};
        \end{axis}
      \end{tikzpicture}
      \caption{The amount of visible octree nodes over the course of the test animation shown in green for 
      per-octree occlusion culling and in orange for per-meshlet occlusion culling. 
      The average amount of visible octree nodes was \emph{8,207} for per-octree occlusion culling, which is 
      marked as the blue dotted line, and \emph{3,832} for per-meshlet occlusion culling, which is marked in 
      as the red dotted line.}
      \label{plt:terrain-256-culling-res-nodes}
    \end{center}
  \end{figure}

% ----------------------------------------------------------------------------------------


\noindent
The terrain model shows a rather stable occlusion over time, with a ratio of about $58.4\%$ culled voxels 
using the per-octree culling configuration, and about $81.1\%$ voxels being culled in the per-meshlet 
configuration. 



\subsection*{Terrain - $256^3$}

% -------------------------------------- HAIRBALL 256 -------------------------------------

\begin{figure}[h]              % Hairball 256 Voxels Test Anim
    \begin{center}
      \begin{tikzpicture}
        \begin{axis}[
            width=\linewidth, % Scale the plot to \linewidth
            height=100px,
            xlabel={Frames},
            ylabel={Visible Voxels},
            grid,
            xmin=0,
            xmax=940,
            ymin=400000,
            ymax=800000
          ]
          \addplot[green, no marks, solid] table[col sep=comma, x=frame, x expr=\thisrow{frame} * 940 / 940, y=visible_voxels]{./plotdata/hairball_256_voxels.csv};
          \addplot[blue, dotted, no marks, domain=0:940, samples=50] {697549};
          \addplot[orange, no marks, solid] table[col sep=comma, x=frame, x expr=\thisrow{frame} * 940 / 1187, y=visible_voxels]{./plotdata/hairball_256_voxels_pmoc.csv};
          \addplot[red, dotted, no marks, domain=0:940, samples=50] {0};
        \end{axis}
      \end{tikzpicture}
      \caption{The amount of visible voxels over the course of the test animation shown in green for 
      per-octree occlusion culling, and in orange for per-meshlet occlusion culling. 
      The average amount of visible voxels was \emph{697,549} for per-octree occlusion culling, which is 
      marked as the blue dotted line, and \emph{0} for per-meshlet occlusion culling, marked in red.}
      \label{plt:terrain-256-culling-res-voxels}
    \end{center}
  \end{figure}


  \begin{figure}[h]            % Hairball 256 OT Nodes Test Anim
    \begin{center}
      \begin{tikzpicture}
        \begin{axis}[
            width=\linewidth, % Scale the plot to \linewidth
            height=100px,
            xlabel={Frames},
            ylabel={Visible Nodes},
            grid,
            xmin=0,
            xmax=940,
            ymin=10000,
            ymax=30000
          ]
          \addplot[green, no marks, solid] table[col sep=comma, x=frame, x expr=\thisrow{frame} * 940 / 940, y=visible_nodes]{./plotdata/hairball_256_nodes.csv};
          \addplot[blue, dotted, no marks, domain=0:940, samples=50] {21229};
          \addplot[orange, no marks, solid] table[col sep=comma, x=frame, x expr=\thisrow{frame} * 940 / 1187, y=visible_nodes]{./plotdata/hairball_256_nodes_pmoc.csv};
          \addplot[red, dotted, no marks, domain=0:940, samples=50] {0};
        \end{axis}
      \end{tikzpicture}
      \caption{The amount of visible octree nodes over the course of the test animation shown in green for 
      per-octree occlusion culling and in orange for per-meshlet occlusion culling. 
      The average amount of visible octree nodes was \emph{21,229} for per-octree occlusion culling, which is 
      marked as the blue dotted line, and \emph{0} for per-meshlet occlusion culling, which is marked in 
      as the red dotted line.}
      \label{plt:terrain-256-culling-res-nodes}
    \end{center}
  \end{figure}

% ----------------------------------------------------------------------------------------


[@TODO: Remove other resolutions]

\noindent
The torus model shows in particular how the amount of visible voxels is very dependent on the 
viewing angle of the camera. In figures \ref{plt:torus-256-culling-res-voxels} and 
\ref{plt:torus-256-culling-res-nodes} two immense drops in voxel and octree visibility can be noticed.
They occured when the torus was visible from the side, hiding the hole in the middle and providing excellent 
self-occlusion for the far end of the torus. Compared to the other meshes, the amount of visible voxels 
varied the most on the torus, ranging from around $160,000$ to almost $430,000$ voxels. This is due to the 
algorithm favoring solid models without holes in them. The torus is a great example for showing the limits of 
the implementation, having a rather low volume, a completely round shape with no straight edges and significant 
parts of the model being empty space. \\

\noindent
The results show that a model like the torus is not optimal for the use in actual performance agnostic applications.
Because of its shape, the performance is assumed to rather unstable, as opposed to some of the other models, which 
consistently cull a similar amount of voxels.


[@TODO: Add best occluder count]

\begin{table}[h]
  \begin{tabular}{|lccccc|}
  \hline
  \multicolumn{6}{|c|}{\textbf{Scene Resolution: $256^3$ - Per-Octree Occlusion Culling}}                                                                                                                                                                                         \\ \hline
  \multicolumn{1}{|l|}{}                          & \multicolumn{1}{|l|}{\textbf{Stanford Lucy}}  & \multicolumn{1}{l|}{\textbf{Stanford Bunny}}  & \multicolumn{1}{l|}{\textbf{Torus}}   & \multicolumn{1}{l|}{\textbf{Terrain}}     & \multicolumn{1}{l|}{\textbf{Hairball}}    \\ \hline
  \multicolumn{1}{|l|}{Total Voxel Count}         & \multicolumn{1}{c|}{331,254}                  & \multicolumn{1}{c|}{3,379,738}                & \multicolumn{1}{c|}{2,311,006}        & \multicolumn{1}{c|}{953,362}              & \multicolumn{1}{c|}{1,652,435}            \\
  \multicolumn{1}{|l|}{Avg. Visible Voxels}       & \multicolumn{1}{c|}{140,842}                  & \multicolumn{1}{c|}{385,210}                  & \multicolumn{1}{c|}{359,313}          & \multicolumn{1}{c|}{396,228}              & \multicolumn{1}{c|}{697,549}              \\
  \multicolumn{1}{|l|}{Avg. Culled Voxels}        & \multicolumn{1}{c|}{190,412}                  & \multicolumn{1}{c|}{2,994,528}                & \multicolumn{1}{c|}{1,951,693}        & \multicolumn{1}{c|}{557,134}              & \multicolumn{1}{c|}{954,886}              \\
  \multicolumn{1}{|l|}{Avg. Culled Voxel Ratio}   & \multicolumn{1}{c|}{\textbf{57.5 \%}}         & \multicolumn{1}{c|}{\textbf{88.6 \%}}         & \multicolumn{1}{c|}{\textbf{84.5 \%}} & \multicolumn{1}{c|}{\textbf{58.4 \%}}     & \multicolumn{1}{c|}{\textbf{57.8 \%}}     \\ \hline
  \multicolumn{1}{|l|}{Total Octree Nodes}        & \multicolumn{1}{c|}{6,830}                    & \multicolumn{1}{c|}{57,481}                   & \multicolumn{1}{c|}{39,794}           & \multicolumn{1}{c|}{18,465}               & \multicolumn{1}{c|}{39,591}               \\
  \multicolumn{1}{|l|}{Avg. Visible Nodes}        & \multicolumn{1}{c|}{3,460}                    & \multicolumn{1}{c|}{8,519}                    & \multicolumn{1}{c|}{7,712}            & \multicolumn{1}{c|}{8,207}                & \multicolumn{1}{c|}{21,229}               \\
  \multicolumn{1}{|l|}{Avg. Culled Nodes}         & \multicolumn{1}{c|}{3,370}                    & \multicolumn{1}{c|}{48,962}                   & \multicolumn{1}{c|}{32,082}           & \multicolumn{1}{c|}{10,258}               & \multicolumn{1}{c|}{18,362}               \\
  \multicolumn{1}{|l|}{Avg. Culled Node Ratio}    & \multicolumn{1}{c|}{\textbf{49.3 \%}}         & \multicolumn{1}{c|}{\textbf{85.2 \%}}         & \multicolumn{1}{c|}{\textbf{80.6 \%}} & \multicolumn{1}{c|}{\textbf{55.6 \%}}     & \multicolumn{1}{c|}{\textbf{46.4 \%}}     \\ \hline
  \multicolumn{1}{|l|}{Avg. Node Population}      & \multicolumn{1}{c|}{\textbf{48.5 \%}}         & \multicolumn{1}{c|}{\textbf{91.9 \%}}         & \multicolumn{1}{c|}{\textbf{90.7 \%}} & \multicolumn{1}{c|}{\textbf{80.7 \%}}     & \multicolumn{1}{c|}{\textbf{65.2 \%}}     \\
  \multicolumn{1}{|l|}{Best Occluder Count}       & \multicolumn{1}{c|}{0}                        & \multicolumn{1}{c|}{0}                        & \multicolumn{1}{c|}{0}                & \multicolumn{1}{c|}{0}                    & \multicolumn{1}{c|}{0}                    \\ \hline
  

  \end{tabular}
\end{table}

% Avg. Node Population is for the complete, non-culled model. The higher the more efficient the model can be culled


\section{Performance Results}

The performance results were measured for specifc frames in the standardized camera animation cycle. For each 
model, a couple of frames were located and further analyzed to gain more information about the rendering 
process. The frames selected were usually the ones with the most respective the fewest voxels visible. Additionally,
a few more frames were analyzed, which provided an average voxel count. All measurements were done for both 
culling configurations (per-octree culling and per-meshlet culling) and were repeated multiple times to compensate 
for moise. The average measurements are listed below. \\

\noindent
[@TODO: Add measurements]


















\begin{table}[h]
    \begin{tabular}{|lccccc|}
    \hline
    \multicolumn{6}{|c|}{\textbf{Scene Resolution: $256^3$}}                                                                                                                                                                                                         \\ \hline
    \multicolumn{1}{|l|}{}                          & \multicolumn{1}{|l|}{\textbf{Stanford Lucy}}  & \multicolumn{1}{l|}{\textbf{Stanford Bunny}}  & \multicolumn{1}{l|}{\textbf{Torus}}   & \multicolumn{1}{l|}{\textbf{Terrain}}     & \multicolumn{1}{l|}{\textbf{Hairball}}    \\ \hline
    \multicolumn{1}{|l|}{Total Voxel Count}         & \multicolumn{1}{c|}{331,254}                  & \multicolumn{1}{c|}{-}                        & \multicolumn{1}{c|}{-}                & \multicolumn{1}{c|}{-}                    & \multicolumn{1}{c|}{-}                    \\
    \multicolumn{1}{|l|}{Culled Voxels}             & \multicolumn{1}{c|}{207,466}                  & \multicolumn{1}{c|}{-}                        & \multicolumn{1}{c|}{-}                & \multicolumn{1}{c|}{-}                    & -                                         \\
    \multicolumn{1}{|l|}{Voxel Culling Ratio}       & \multicolumn{1}{c|}{\textbf{62,63 \%}}        & \multicolumn{1}{c|}{-}                        & \multicolumn{1}{c|}{-}                & \multicolumn{1}{c|}{-}                    & -                                         \\ \hline
    \multicolumn{1}{|l|}{Octree Nodes}              & \multicolumn{1}{c|}{6,830}                    & \multicolumn{1}{c|}{-}                        & \multicolumn{1}{c|}{-}                & \multicolumn{1}{c|}{-}                    & -                                         \\
    \multicolumn{1}{|l|}{Culled Octree Nodes}       & \multicolumn{1}{c|}{3,774}                    & \multicolumn{1}{c|}{-}                        & \multicolumn{1}{c|}{-}                & \multicolumn{1}{c|}{-}                    & -                                         \\
    \multicolumn{1}{|l|}{Octree Culling Ratio}      & \multicolumn{1}{c|}{\textbf{55,25 \%}}        & \multicolumn{1}{c|}{-}                        & \multicolumn{1}{c|}{-}                & \multicolumn{1}{c|}{-}                    & -                                         \\ \hline
    \end{tabular}
\end{table}


\subsubsection*{GPU Timings}

\begin{table}[h]
    \begin{tabular}{|lccccc|}
    \hline
    \multicolumn{6}{|c|}{\textbf{Scene Resolution: $256^3$}}                                                                                                                                                                                                         \\ \hline
    \multicolumn{1}{|l|}{}                          & \multicolumn{1}{l|}{\textbf{Stanford Lucy}}   & \multicolumn{1}{l|}{\textbf{Stanford Bunny}}  & \multicolumn{1}{l|}{\textbf{Torus}}   & \multicolumn{1}{l|}{\textbf{Terrain}}     & \multicolumn{1}{l|}{\textbf{Hairball}}    \\ \hline
    \multicolumn{1}{|l|}{Overall GPU Time}          & \multicolumn{1}{c|}{2.3009 ms}                & \multicolumn{1}{c|}{-}                        & \multicolumn{1}{c|}{-}                & \multicolumn{1}{c|}{-}                    & \multicolumn{1}{c|}{-}                    \\
    \multicolumn{1}{|l|}{Depth Pre-Pass}            & \multicolumn{1}{c|}{402.7 us}                 & \multicolumn{1}{c|}{-}                        & \multicolumn{1}{c|}{-}                & \multicolumn{1}{c|}{-}                    & -                                         \\
    \multicolumn{1}{|l|}{Dispatch Mesh (Draw)}      & \multicolumn{1}{c|}{1.75 ms}                  & \multicolumn{1}{c|}{-}                        & \multicolumn{1}{c|}{-}                & \multicolumn{1}{c|}{-}                    & -                                         \\ \hline
    \end{tabular}
\end{table}





\section{Per-Meshlet Culling Results}

\subsection*{Laptop Setup}

\subsubsection*{Culling Effect}

\begin{table}[h]
    \begin{tabular}{|lccccc|}
    \hline
    \multicolumn{6}{|c|}{\textbf{Scene Resolution: $256^3$}}                                                                                                                                                                                                         \\ \hline
    \multicolumn{1}{|l|}{}                          & \multicolumn{1}{|l|}{\textbf{Stanford Lucy}}  & \multicolumn{1}{l|}{\textbf{Stanford Bunny}}  & \multicolumn{1}{l|}{\textbf{Torus}}   & \multicolumn{1}{l|}{\textbf{Terrain}}     & \multicolumn{1}{l|}{\textbf{Hairball}}    \\ \hline
    \multicolumn{1}{|l|}{Total Voxel Count}         & \multicolumn{1}{c|}{331,254}                  & \multicolumn{1}{c|}{-}                        & \multicolumn{1}{c|}{-}                & \multicolumn{1}{c|}{-}                    & \multicolumn{1}{c|}{-}                    \\
    \multicolumn{1}{|l|}{Culled Voxels}             & \multicolumn{1}{c|}{257,961}                  & \multicolumn{1}{c|}{-}                        & \multicolumn{1}{c|}{-}                & \multicolumn{1}{c|}{-}                    & -                                         \\
    \multicolumn{1}{|l|}{Voxel Culling Ratio}       & \multicolumn{1}{c|}{\textbf{77,87 \%}}        & \multicolumn{1}{c|}{-}                        & \multicolumn{1}{c|}{-}                & \multicolumn{1}{c|}{-}                    & -                                         \\ \hline
    \multicolumn{1}{|l|}{Octree Nodes}              & \multicolumn{1}{c|}{6,830}                    & \multicolumn{1}{c|}{-}                        & \multicolumn{1}{c|}{-}                & \multicolumn{1}{c|}{-}                    & -                                         \\
    \multicolumn{1}{|l|}{Culled Octree Nodes}       & \multicolumn{1}{c|}{4,329}                    & \multicolumn{1}{c|}{-}                        & \multicolumn{1}{c|}{-}                & \multicolumn{1}{c|}{-}                    & -                                         \\
    \multicolumn{1}{|l|}{Octree Culling Ratio}      & \multicolumn{1}{c|}{\textbf{63,38 \%}}        & \multicolumn{1}{c|}{-}                        & \multicolumn{1}{c|}{-}                & \multicolumn{1}{c|}{-}                    & -                                         \\ \hline
    \end{tabular}
\end{table}


\subsubsection*{GPU Timings}

\begin{table}[h]
    \begin{tabular}{|lccccc|}
    \hline
    \multicolumn{6}{|c|}{\textbf{Scene Resolution: 256\textasciicircum{}3}}                                                                                                                                                                                                         \\ \hline
    \multicolumn{1}{|l|}{}                          & \multicolumn{1}{l|}{\textbf{Stanford Lucy}}   & \multicolumn{1}{l|}{\textbf{Stanford Bunny}}  & \multicolumn{1}{l|}{\textbf{Torus}}   & \multicolumn{1}{l|}{\textbf{Terrain}}     & \multicolumn{1}{l|}{\textbf{Hairball}}    \\ \hline
    \multicolumn{1}{|l|}{Overall GPU Time}          & \multicolumn{1}{c|}{1.7162 ms}                & \multicolumn{1}{c|}{-}                        & \multicolumn{1}{c|}{-}                & \multicolumn{1}{c|}{-}                    & \multicolumn{1}{c|}{-}                    \\
    \multicolumn{1}{|l|}{Depth Pre-Pass}            & \multicolumn{1}{c|}{388.3 us}                 & \multicolumn{1}{c|}{-}                        & \multicolumn{1}{c|}{-}                & \multicolumn{1}{c|}{-}                    & -                                         \\
    \multicolumn{1}{|l|}{Dispatch Mesh (Draw)}      & \multicolumn{1}{c|}{1.19 ms}                  & \multicolumn{1}{c|}{-}                        & \multicolumn{1}{c|}{-}                & \multicolumn{1}{c|}{-}                    & -                                         \\ \hline
    \end{tabular}
\end{table}







- Results of the case study

- Table for drawn vs occluded voxels in numbers and percent
- Table for Execution times (full frame, prepass, draw, ...)
- Table for triangles drawn vs. culled 
- Table for 
