\chapter{Case Study} \label{cpt-case-study}

Our case study is based on an implementation within the framework \emph{Diligent Engine}.[@TODO: cite DiligentEngine]
This framework includes a multi-\ac{API} rendering backend, with modern integrations for \ac{GPU}-driven rendering.
One of these modern features is the support for mesh shading in Microsoft's D3D12 rendering \ac{API}. 
The support for modern rendering features while still maintaining access to all core features, makes 
\emph{Diligent Engine} a good place to start from. For the case study, we enhanced the mesh shading pipelin 
to better fit our purposes of drawing a huge amount of voxels. We also made small changes to the integrated 
view-frustum culling, which was updated to work on meshlet-groups rather than meshlets themselves. This change 
was made during the restructuring of the draw tasks. The updated pipeline changes how meshes are dispatched 
because of the use of additional acceleration structures. This chapter provides an overview of all the changes and 
additions to the framework and how the pipeline works in specific. The implementation details can be found in the 
appendix \ref{cpt-appendix}.

\section{Pipeline Overview}

\begin{figure}[h]
    \centering
    \includegraphics[width=\linewidth]{images/graphics/pipeline-initialization.png}
    \caption{The initialization process of the rendering pipeline. Depending on the voxel model, an octree node 
    can hold anything between zero and \emph{n} voxels, \emph{n} being the amount of threads per threadgroup}
    \label{fig:pipeline-initialization}
\end{figure}

The pipeline is, as usually, split into an initialization routine and an update loop. The initialization is 
called once during the beginning of the execution flow and the render loop is initiated after the initialization 
finished. Then, the loop is continuously called - once per frame. Figure \ref{fig:pipeline-initialization} shows 
the initialization procedure. For the purpose of this case study, a single, solid voxel mesh is loaded, but this 
could as well be a scene consisting of multiple solid voxel models. After loading any voxel model, an octree is 
created that covers the complete scene - in this case the bouding volume of the voxel model. As discussed in 
chapter \ref{subsec-highres-svo-dags}, it is recommended to use a highly efficient and compressed octree 
implementation like an \ac{SVO} or a Sparse Voxel \ac{DAG} \cite{Kampe2013}. For the purpose of our case study, 
we used a custom octree implementation which refers to indices in a global \emph{voxel position buffer}, as 
shown in figure \ref{fig:voxelpos-octreenode-buffer}.\\

\begin{figure}[h]
    \centering
    \includegraphics[width=\linewidth]{images/graphics/voxelpos-octreenode-buffer.png}
    \caption{The voxel position buffer and the octree node buffer. The latter one providing a 
    specific structure to the first one.}
    \label{fig:voxelpos-octreenode-buffer}
\end{figure}

\noindent
Since the \ac{GPU} is supposed to generate a lot of voxels on the fly, data buffers like the voxel position buffer 
need to be considered.
For structuring the data, various options are available. A first approach involves the voxels being layed 
out as individual meshlets, which was our initial idea. This means that individual voxels can be culled and 
each \ac{GPU} thread generates one voxel. This would mean that only the voxel position buffer is needed. 
The amplification shader takes the positions, culls meshlets against the view-frustum and dispatches the 
mesh shader with the given data. As long as no spatial container like an octree is used, this approach works 
fine. When considering the use of an octree, however, another layout serves better. In this case, each \ac{GPU} 
threadgroup takes care of one octree node, with the maximum amount of voxels per node being equal to the 
amount of threads per threadgroup. Using this layout, each thread in a threadgroup again takes care of one 
voxel. The octree node information now can store additional information, which can be used for octree node 
based view frustum culling. To generate this data, the octree is queried during the initialization, resulting 
in an extra \emph{octree node buffer} which stores an index into the voxel position buffer and a count of voxels,
associated with the node. After sorting the voxel position buffer, this additional structure identifies voxel 
positions that are located adjacent to each other inside an octree node. Figure \ref{fig:voxelpos-octreenode-buffer} 
shows the data layout and how it relates to the voxel position buffer. 

\begin{figure}[h]
    \centering
    \includegraphics[width=\linewidth]{images/graphics/render-loop.png}
    \caption{The rendering loop of the rendering pipeline.}
    \label{fig:pipeline-loop}
\end{figure}


% @TODO: Meshlet Creation -> Voxel

- Meshlet creation for voxel meshes is trivial since meshlets don't have to be per-computed
- Meshlet culling is also straight forward since Voxels are inherently AABBs
- Where can I put the initial thought of having voxels as meshlets? -> maybe motivation? 

\section{Setup}

% @TODO: Add reference to Diligent Engine's github etc.
For the case study, a starting point is used which provides a reliable and comparable environment.
The framework used is the \emph{Diligent Engine} which already implements state of the art, multi-
platform and multi-API rendering. \\

\noindent



// --------------------------------------------------------------------------------- //
Motivation:
Use Meshlet Culling in voxel rendering to optimize GPU Driven Voxel Rendering


Implementation Considerations:

- Meshlet Culling at first, then problem, because meshlet culling algorithm depends on different algos
    - Meshlet Backface Culling -> Not possible because Meshlets are voxels in this case
    - Meshlet Occlusion Culling -> Using 2 Pass Depth Occlusion Culling sounds good!
    - 2PDOC relies on drawing best occluders which are usually hand picked by artists (buildings)
        -> We can dynamically pick best occluders by selecting full octree nodes as best occluders!

- Optimize octree by using High Res SVOs (https://www.cse.chalmers.se/~uffe/HighResolutionSparseVoxelDAGs.pdf).
    - As shown in the paper, here we also only need to encode if a node is filled or not. This way we can 
    optimize memory and proccessing speed! (Not done here because of limitation in loading and voxelizing models.)

- Explain why Mesh Shading is useful here and what the differences to HiZ and Two-Pass OC are!

- Align octree bounds with outer most voxel bounds, so no misalignment happens!
    
- Limitations: 
    - Using Mesh Shading, we occlude meshlets against other meshlets, instead of instances against other
    instances. This might be a limiting factor!

- Worse performance on slopes? -> Check and measure!

- Larger nodes which are not being split can be "full" without being full!

// --------------------------------------------------------------------------------- //
